#!/usr/bin/env pebl
##  This is a PEBL script that acts as a cross-platform 
##  launcher for PEBL.
##
## Version 0.4: adds a column (name) to an experiment chain, and   
##              so is not backward compatible.
##
## Version 0.3: Adds parameter setting (version 0.14), 
## data file combining, http version check.  
##
##  Version 0.2: Initial release, to accompany PEBL 0.13.
##  (c) 2011-2016 Shane T. Mueller, Ph.D. smueller@obereed.net
##

##rename to Draw() for some time debugging
define DrawX(thing:0)
{
   Print("Drawing: " +thing + " " + GetTime())
   if(thing==0)
   {
     :Draw()
	 
   } else{
     :Draw(thing)
   }
}


define Start(p)
{

	##Print("startout workking directory" + gWorkingDirectory)
    gdebug <- 0
    gUseReloc <- 0
                   ## NOT from an installation in Program Files, but from
                   ##A PEBL subdirectory of the current working directory.
 
    gPEBLVersion <- "2.0"
    gScriptName <- "PEBL Launcher " + gPEBLVersion
    gvsync <- 0    


   if(gDebug)
     {
	   gWin <- MakeWindow()
   
	   gMessage <- EasyLabel("Started",200,200,gWin,12)
           Draw()
 	   WaitForANyKeyPress()
	  }
     gsystemType <- GetSystemType()
     ghome <- GetHomeDirectory()
	
	
    if (gUseReloc)
	    { 
          gPEBLAppDirectory <- GetWorkingDirectory()
           gPEBLDIR <- "PEBL"

	 Print("working directory:  " + GetWorkingDirectory())
	 Print("gPEBLDIr:           " + gPEBLDir)
     Print("gExecutableName:    " + gExecutableName)
	 Print("gHome:              " + gHome)
	 Print("gPEBLBasePath:      " + gpeblBasePath)
	 Print("gPEBLResourcePath:  " + gPEBLResourcePath)
	 Print("gPEBLAppDirectory:  " + gPEBLAppDirectory)
	 
           gDest <- ".\" ##was ghome. 
           gHome <- ""

		   FileSelect(["default"],p) ##Giving an argument here will specify a data file
		} else {
	
     if(Length(p)>0)
	  {
  	       gPEBLDir  <- First(p)
	  } else {
           gPEBLDir <- GetWorkingDirectory()+"\..\"
	  }
	  # gPEBLDir <- GetWorkingDirectory()+"\..\"
	  # gPEBLDir <- ""
	  
	  if(gDebug)
	  {
        gMessage.text <- gPEBLDir
	    Draw()
	    WaitForANyKeyPress()
	  }
	  

	if(gSystemtype == "WINDOWS")
	   {
 	    if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"    ##win7 or later?
		} elseif (FileExists(ghome+"\My Documents"))
		{
		   ##winxp or earlier?
		   doc <- "\My Documents"
		} else {
		
		    #We should allow user-selected here, but it will take  a little care to do right.
		    SignalFatalError("Unable to locate My Documents or Documents folder")
		}
		
        } else {
	     #On linux/osx
             doc <- "/Documents"
	}

      gDest <- ghome+ doc + "/pebl-exp."+gPEBLVersion
      Print("starting in " + gDest)

	 
     ##Decide whether to run for the first time
	  if(FileExists(gdest))
	   {
	     list <- GetDirectoryListing(gdest)
          
	      if(Length(list)>2)
               {
			      ##We should keep track of the initial working directory, which is where 
				  ##the resources, application, etc. should be.  But we need to set
				  ##WD to the location we want it to be at--gDest.
			      gPEBLAppDirectory <- GetWorkingDirectory()
                  SetWorkingDirectory(gdest)
                  FileSelect(["default.config"],p) ##Giving an argument here will specify a data file
                 } else{
                  RunFirstTime(p)
		 }
            } else {

	       Print("Running for the first time")
	       RunFirstTime(p)
	  }
  }
}


define FileSelect(p,resources)
{
 
 ##Set this from 1 to 0 to turn off automatic subject code incrementation
 ##it increments the previous code by one, to avoid overwriting
 gAutoSubCode <- 1

 gLastUpdate <- GetTime() ##keep track of updates

 gScreenresInitial <- GetCurrentScreenResolution()

 ###set the configuration/chain name: use 'default.config' as default.
 if(Length(p) >0)
   {
      gConfigName <- First(p)
      if(gConfigName==0)
        {
           gConfigName <- "default.config"
        }
    }else{
       gConfigName <- "default.config"
   }

  ##This allows you to open up the description file directly.
  gEditDescription <- 0

  systemType <- GetSystemType()

   gFilters <- ["*.pbl" , "data files","*.*"]

  if(systemType == "LINUX") 
   {

    gViewerCommand <- "gedit"
    gPEBLName      <- "pebl2"
    gOpenManual    <- "acroread /usr/local/share/pebl2/doc/PEBLManual"+gPEBLVersion+".pdf&"
    gOpenURL        <- "firefox"
    gManualLoc      <- "/usr/local/share/pebl2/doc/PEBLManual"+gPEBLVersion+".pdf"

		
   }elseif(systemType=="WINDOWS")   {
     
	 
	 	  ##Debugging:
      #SystemCall("echo " + gQuote+ gPEBLDir+gQuote +" & pause","")
	
#	 Print("working directory:  " + GetWorkingDirectory())
#	 Print("gPEBLDIr:           " + gPEBLDir)
 #    Print("gExecutableName:    " + gExecutableName)
#	 Print("gHome:              " + gHome)
#	 Print("gPEBLBasePath:      " + gpeblBasePath)
#	 Print("gPEBLResourcePath:  " + gPEBLResourcePath)
#	 Print("gPEBLAppDirectory:  " + gPEBLAppDirectory)
	 
	# Print("gPEBLAppName:       " + gPEBLAppName)

		 
#	      gPEBLName     <- gQuote+gPEBLAppDirectory+ "\" + gExecutableName  +gQuote+ " "

	 
	 
	 ##There should be a built-in that does this.
	# Print("looking for: " + gPeblDir+"bin\pebl2.exe-- " + FileExists(gPEBLDir+"\pebl2.exe"))
    # Print(GetDirectoryListing(".\"))
	# Print("fileexists:" + FileExists(gPEBLAppDirectory+ "\" + gExecutableName))

	if (not FileExists(gPEBLAppDirectory+ "\" + gExecutableName))
	 	     {
 #               Print("Not here")
 #				Print(FileExists(gQuote+"%ProgramFiles(x86)%\\PEBL2\bin\pebl2.exe"+gQuote))
 #				Print("Dir:'" + GetDirectoryListing("%ProgramFiles(x86)%"))
				
			  #if(FileExists(gQuote+"%ProgramFiles(x86)%\PEBL2\bin\pebl2.exe"+gQuote))
               if(FileExists(gPEBLAppDirectory+"\pebl2.exe"))
			  {
  		           gPEBLDir <- "%ProgramFiles(x86)%\PEBL2"
			   } elseif(FileExists(gQuote+"%ProgramFiles%\PEBL2\bin\pebl2.exe"+gQuote))
			   {
			     gPEBLDir <- gQuote+"%ProgramFiles%\PEBL2"+ gQuote
			   } else {
			      if(gDebug)
				   {
                     MessageBox("Unable to find PEBL Base Directory.  Please hard-code",gWin)
                   }
                   gPEBLDir <- "%ProgramFiles%\PEBL2"   
                   SignalFatalError("Unable to find PEBL Base Directory on file system:" + gPEBLDir)
				}
			}
    
     gViewerCommand <- "c:\windows\notepad.exe"  ##used as a backup
##     gPEBLName     <- gQuote+gPEBLAppDirectory+ "\" + gExecutableName  +gQuote+ " "
     gPEBLName <- gQuote + gExecutableName + gQuote
	 
     gOpenManual    <- ""
     gManualLoc     <-  gQuote+gPEBLDir+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote
     ##This shouldn't be hard-coded; but for now, change to localize.
#     gManualLoc    <- "C:\Program Files\PEBL\doc\PEBLManual"+gPEBLVersion+".pdf"
     gOpenURL       <- ""

 if(gDebug)
	  {
	     MessageBox("pebl executable name:" + gPEBLName,gWin)
	   }

   }elseif(systemType == "OSX")
   {
     gViewerCommand  <- "open"
#     gPEBLName      <- "/opt/local/bin/pebl"
#     gOpenManual    <- "acroread /opt/local/share/pebl/doc/PEBLManual"+gPEBLVersion+".pdf"
 

     gPEBLName      <- gExecutableName
#Print("PEBL NAME: "+gPEBLName)
#     Print("PEBL Dir:  "+gPEBLDir)
#     Print("Resources:" + resources)
#     Print("Resources2:" + gPEBLResourcePath)

     gOpenManual    <- ""
     gManualLoc     <- "PEBLManual"+gPEBLVersion+".pdf"

   }

   gSleepEasy <- 1

   ReadConfigFile(gConfigname)
   if(not FileExists(gConfigName))
   {
      Saveconfig(gconfigname)
   }


           	   
    parPairs <- [["checkfornew",0],
                 ["newest","0.14"],
	             ["pwhash",""],
		         ["screensize", "large"],
 	             ["usescreenshots",1]
                ]


    MakeDirectory("params")		 
    gParams  <- CreateParameters(parpairs,"params/launcher.pbl.par")

   
   if(gParams.ScreenSize =="large")
   {
     gVideoWidth <- 1000
     gVideoheight <- 700
   }elseif(gParams.ScreenSize=="small")
   {
     gVideoWidth <- 1000
     gVideoheight <- 600
   }

   win <- MakeWindow("grey90")

   gWin <- win
   Draw()

   if(not gParams.pwhash=="2627692e567165c7a474f3ea97c07912")
   {
      Draw()        
	  gPasswordEntered <- 0
      PopUpScreen(win)

   }else{
      gPasswordEntered <- 1

   }

   SaveParamFile(gParams,"params/launcher.pbl.par")
   
   ##make a dummy object Inside() will recognize as a click on the window.
   gWinDummy <- MakeCustomObject("dummy")
   gWinDummy.name <- "<CUSTOMOBJECT>"
   gWinDummy.x <- gVideoWidth/2
   gWinDummy.y <- gvideoHeight/2
   gWinDummy.width <- gVideoWidth
   gWinDummy.height <- gVideoheight
   gWinDummy.win <- win


  ##Now, determine the proper translation strings.
  GetStrings(gLanguage)

   fontsize <- 11
   yheight <- 14 

   menubar <- Rectangle(gVideoWidth/2,8,gVideoWidth,16,MakeColor("grey20"),1)
   AddObject(menubar,win)
   menu1 <- MakeMenu("File",10,0,win,14,120,
              ["Quit"],
              ["ExitPEBL"])

   menu2<- MakeMenu("Options",90,0,win,14,120,    
              ["Change launcher size","Set password","Enable/Disable screenshots"],
              ["ChangeLauncherSize","SetPassword","EnableDisableScreenshots"])

    menu3 <- MakeMenu("Help",180,0,win,14,120,["About","Manual","Website", "PEBL Wiki","Tutorial","Review PEBL","Donate","Cite"],
          ["AboutMessage","OpenManual","GoToWeb","VisitWIKI","Tutorial","Review","Donate","CitePEBL"])
  if(gFullscreen)
    {
      fstext  <- "X"
    } else { 
      fstext <- ""
    }

   ##keep track of the gOffset/select pairs when you move to new directories.
   selectStack <- []
   gselected <-1     #Which item is selected in the fileview
   gOffset <- 0      #gOffset in the fileview

   MakeDirectory("logs")
   logFile <- FileOpenAppend("logs/PEBLLaunch-log.txt")

   xbase <- 10

   gDirchain <- ["."]  ##this is a history of the directories you have 
                      ##navigated to.

######################################################
#####################################################
 ## first column of stuff
   ybase1 <- 34  ##base of column 1
#   gYbase <- ybase1

   gPath <- EasyLabel(DirListToText(gDirChain),(xbase+100), ybase1+15, win,fontsize)
   yheight <- gPath.height
   gYHeight <- yHeight
   MoveCorner(gPath,xbase,ybase1+10)

   portalheight <- 418
   gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
   gFlatfilelist <- Flatten(gfilelist)
   
   dirlist <- DirToText(First(gfilelist),Second(gfilelist),   
                             gDirChain)


  gPortal <- MakeScrollbox(dirlist,"File listing",
                             xbase,ybase1+27,
			     win,fontsize,
			     200, portalheight,1)



   font <- MakeFont(gPEBLBaseFont,0,fontsize,MakeColor("black"),MakeColor("white"),1)

  
   run     <- MakeButton(gRuntext,xbase+100,ybase1,win,200) 


   edit  <- MakeButton(gOpenText,gPortal.x+gPortal.width/2,  gPortal.y+portalheight+14,win,gportal.width-4)
   wiki  <- MakeButton(gWikiText,gPortal.x+gPortal.width/2,  gPortal.y+portalheight+35,win,gportal.width-4)
   combinedata <- MakeButton(gCombineDataText,gPortal.x+gPortal.width/2,gPortal.y+portalheight+56,win,gportal.width-4)
   viewoutput <- MakeButton(gViewDebugText,gPortal.x+gPortal.width/2, gportal.y+portalheight+77,win,gportal.width-4)
   viewerror  <- MakeButton(gViewErrorText,gPortal.x+gPortal.width/2, gPortal.y+portalheight+98,win,gportal.width-4)

   makelauncher <- MakeButton(gMakeLauncherText,gPortal.x+gPortal.width/2,gPortal.y+portalheight+119,win,gPortal.width-4)
 
 
   translatetest <- MakeButton(gTranslateTestText,gPortal.x+gPortal.width/2,
                                gPortal.y+portalheight+140,win,gPortal.width-4)

   ##################################################
   ##################################################
   ##column 2
   ybase2 <- 35   #base of column 2

   wd   <- EasyLabel("dir: "+GetWorkingDirectory(),(xbase+100), ybase2-25, win,fontsize)
   MoveCorner(wd,xbase+220,ybase2-15)

   ##################################################
   ##################################################
   ##  
   ##  graphical widgets related to the chain launcher.

   ##chain-launcher
#   chaintitle <- EasyLabel(gExpChainText+gConfigName,xbase+210+150,290,win,18)

   chainbox <- MakeScrollbox(MakeExpChainList(gExpChain),gExpchainText+gconfigName,
                        xbase+210,ybase2+165,win,fontsize,340,200,1)
   
  ##We need to custom override the chainbox clickon handler so we can edit
  ##rows directly.
  chainbox.editable <- 1


   box <- chainbox.outer
   box.height <- chainbox.height + 70
   box.y <- box.y + 35


   loadchain  <- MakePulldown(GetConfigFiles(),chainbox.x+10,chainbox.y+chainbox.height-15,win,fontsize,chainbox.width-32,1)
   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }

   launchchain <- MakeButton(gLaunchChainText,chainbox.x+92,
         chainbox.y+chainbox.height+57,win,180)

   randomizeChainBox <-  MakeCheckBox(gRandomizeChainText,
          chainbox.x+chainbox.width-153,
          chainbox.y+chainbox.height+47,win,150)

   SetCheckBox(randomizechainBox,gRandomizeChain)


   insertinchain <- MakeButton(gInsertChainText,xbase+270,chainbox.y+chainbox.height+13,win,95)
   addtochain <- MakeButton(gAddToChainText,xbase+380,chainbox.y+chainbox.height+13,win,95)
   deletestep <- MakeButton(gDeleteStepText,xbase+490,chainbox.y+chainbox.height+13,win,95)

   clearchain <- MakeButton(gClearChainText,xbase+260,chainbox.y+chainbox.height+35,win,70)
   deletechain <- MakeButton(gDeleteChainText,xbase+345,chainbox.y+chainbox.height+35,win,90)
   savechain <- MakeButton(gSaveChainText,xbase+430,chainbox.y+chainbox.height+35,win,70)
   namechain <- MakeButton(gNameChainText,xbase+505,chainbox.y+chainbox.height+35,win,70)

   subjectbox <- EasyTextBox(gsubcode,xbase+350,ybase2+20,win,fontsize,120,yheight)
   sublabel   <- EasyLabel(gPartCode, xbase+270,subjectbox.y+subjectbox.height/2,win,fontsize)
   MoveCorner(sublabel,subjectbox.x-sublabel.width-10,subjectbox.y)
   subboxhighlight <- Rectangle(subjectbox.x+subjectbox.width/2,subjectbox.y+subjectbox.height/2,subjectbox.width,subjectbox.height,MakeColor("red"),0)
   AddObject(subboxhighlight,win)
   Hide(subboxhighlight)

   subplusbutton <-  MakeButton("+",subjectbox.x+subjectbox.width+20,subjectbox.y+5,win,20)

   filter    <- MakeButton("*.pbl",gPortal.x+95,gportal.y+gPortal.height-12,win,172)

###Experimenter code box:
   expbox <- EasyTextBox(gexperimenter,xbase+300,ybase2+40,win,fontsize,60,yheight)
   explabel   <- EasyLabel(gExperCode, expbox.x,expbox.y,win,fontsize)
   MoveCorner(explabel,expbox.x-explabel.width-10,expbox.y)
   expboxhighlight <- Rectangle(expbox.x+expbox.width/2,expbox.y+expbox.height/2,expbox.width,expbox.height,MakeColor("red"),0)
   AddObject(expboxhighlight,win)
   Hide(expboxhighlight)


### Language box:
   langbox <- EasyTextBox(glanguage,xbase+450,ybase2+40,win,fontsize,60,yheight)
   langlabel   <- EasyLabel(gLangCode, langbox.x,langbox.y,win,fontsize)
   MoveCorner(langlabel,langbox.x-langlabel.width-10,langbox.y)
   langboxhighlight <- Rectangle(langbox.x+langbox.width/2,langbox.y+langbox.height/2,langbox.width,langbox.height,MakeColor("red"),0)
   AddObject(langboxhighlight,win)
   Hide(langboxhighlight)


###Command-line options:
   clobox <- EasyTextBox(gCommandLineText,xbase+320,ybase2+60,win,fontsize,200,yheight)
   clolabel   <- EasyLabel(gCommandLineOptions, xbase+440,ybase2+60,win,fontsize)
   MoveCorner(clolabel,clobox.x-clolabel.width-10,clobox.y)
   cloboxhighlight <- Rectangle(clobox.x+clobox.width/2,clobox.y+clobox.height/2,clobox.width,clobox.height,MakeColor("red"),0)
   AddObject(cloboxhighlight,win)
   Hide(cloboxhighlight)


### parameter set pulldown:

   psetlabel   <- EasyLabel(gParameterLabel,xbase+240,ybase2+80,win,fontsize)
   psetbox <- MakePulldown(["default"], xbase+340,ybase2+80,win,fontsize,200,1)
   
   MoveCorner(psetlabel,psetbox.x-psetlabel.width-60,psetbox.y)   
   params     <- MakeButton(gEditParams,psetbox.x-30,psetlabel.y,win,50)


## screen renderer options

   rendererlab <- EasyLabel("Driver options",xbase+240,ybase2+100,win,fontsize)


   drivers <- GetDrivers()
   
   rendererbox <- MakePulldown(drivers,
                                 xbase+340,ybase2+100,win,fontsize,200,1)
   MoveCorner(rendererlab,rendererbox.x-rendererlab.width-5,rendererbox.y)
   SelectPullDownByText(rendererbox,gDriver)
   
### screen resolution
  screenselection <- MakePulldown([gScreenRes],xbase+300,ybase2+120,win,fontsize,120,1)
  gCustomScreenRes <- ""
  UpdateScreenResPulldown(screenselection)

#  screenselection.selected <- Length(screenselection.list)-1
  DrawPulldown(screenselection)



  screenlabel <- EasyLabel(gScreenResLabel,expbox.x,expbox.y+20,win,fontsize)
  Move(screenlabel,screenselection.x-screenlabel.width/2-10,screenselection.y+screenlabel.height/2)

#####################################
   ##Fullscreen checkbox:
  fullscreenbox <-  MakeCheckBox(gFulltext,xbase+210,ybase2+140,win,120)

   demobox <-  MakeCheckBox(gCollectDemoText,xbase+345,ybase2+140,win,200)
   ##Demographics checkbox:
   SetCheckBox(demobox,gNIMHdemographics)


  ## vsync checkbox:
   vsynccheck <- MakeCheckBox(gVSyncText, screenselection.x+screenselection.width+10,
                                          screenselection.y-5,win,100)



   gPortal.list <- DirToText(First(gfilelist),Second(gfilelist),   
                            gDirChain)

   UpdateScrollbox(gPortal)			    
   Draw(gPortal)



   

   #if(gParams.checkfornew)
   if(0)
   {

     newestlabel <- Easylabel("checking for new version", xbase+250, ybase1,win,fontsize)
     MoveCorner(newestlabel,xbase+135,ybase1+20)

#        newest <- GetHTTPText("pebluser.s3-website-us-east-1.amazonaws.com","/latest.txt")
         newest <- ["2.0",100]

     if(First(newest)==200)
	{
	  newestversion <- Second(newest)
	  if(newestversion == "0.14"+CR(1))
           {
                newlab <- "PEBL Up-to-date: Version:"+newestversion
           } else {
                newlab <- "PEBL Out-of-date: Version "+newestversion+" available."
           }
         } else{
              newlab <- GetPEBLVersion()

         }
   }else{

    newlab <-"PEBL Version "+gPEBLVersion
   }

#   newestlabel.text  <- newlab
#   MoveCorner(newestlabel,xbase+100+newestlabel.width/2,ybase2)

   pselected <- -1
   parfiles <- []



############################################
## Column 3
############################################



#   gDescription <- MakeTextBox(gNoDesc,font,420,120)
#   AddObject(gDescription,win)
#   Move(gDescription,570,25)

  gDescription <- MakeScrollingTextBox(gNoDesc,570,25,win,
                                10,420,120,1)


   title <- MakeMenuItem(gPEBLTitle+ GetPEBLVersion(),
                    gVideoWidth/2+100,0,win,win,14,150,"Draw")

   gScreenshotbase <- Rectangle(780,313,420,320,MakeColor("black"),1)
   gScreenshotdummy <- Rectangle(780,313,400,300,MakeColor("white"),1)
   AddObject(gScreenshotbase,win)
   AddObject(gScreenshotdummy,win)
   gScreenshot <- gScreenshotdummy

#########################
########################
## Bottom text windows

  scrollx <- xbase+gPortal.width+10
  scrolly <- gPortal.y+gPortal.height
  scrollw <- gVideoWidth-scrollX - 10
  scrollH <- gVideoHeight-scrollY - 10

  gStdErrList <- "file: stderr.txt"
  gStdOutList <- "file: stdout.txt"

  gMessageBox <- MakeScrollingTextBox(gStdOutList,scrollX, scrollY,
                                      win,fontsize,scrollW,scrollH,1)

  fptb <- gMessageBox.box
  fptb.font <- Makefont(gPEBLBaseFontMono,0,fontsize,MakeColor("black"),MakeColor("white"),0)

  gMenuStdOut <- MakeMenuItem("Debug messages",gMessageBox.x+9,    gMessageBox.y-3,win,win,14,140,"UpdateStdOut")
  gMenuStdErr <- MakeMenuItem("Error messages",gMessageBox.x+160,  gMessageBox.y-3,win,win,14,140,"UpdateStdErr")

  gMenuReload <-  MakeMenuItem("Reload",gMessagebox.x+310,gMessageBox.y-3,win,win,14,80,"ReloadStdOutErr")

  gStdouthighlight <- Rectangle(gMenuStdOut.x+gMenuStdout.width/2,
                               gMenuStdOut.y+gMenuStdout.height/2,
                               gMenuStdOut.width+2,gMenuStdOut.height+2,
                                MakeColor("blue"),0)

  AddObject(gStdouthighlight,win)			       
  UpdateStdout(gMenuStdOut,[0,0])


       vals <- [gPortal,chainbox,insertinchain,deletestep,gMessageBox,
	   run,subjectbox,fullscreenbox,expbox,langbox,
	   addtochain,clearchain,launchchain,viewoutput,viewerror,
	   edit,gMenuStdErr,gMenuStdOut,gMenuReload,
	   gDescription,demobox,savechain,loadchain,wiki,
           subplusbutton,clobox,filter,namechain,    #donate,review,
           screenselection, randomizeChainBox,params,  combinedata,psetbox,
          deletechain,menu1,menu2,menu3,makelauncher,
	  translatetest,vsynccheck,rendererbox]

      returns <- [1,2,3,4,0,
				   6,7,8,9,10,
				   11,12,13,14,15,
				   16,0,0,0,
				   21,22,23,24,25,
				   26,27,28,39,     #29,30,
				   31,32,33,34,35,
				   36,0,0,0,37,
				   38,40,41]



   Draw()
   gCont <- 1
   while(gCont)
    { 
	gDirChainUpdated <- 0

   ########################################
   ##This updates the parfiles if needed.
   ##it should probably be contingent on portal-clicking...


    prevparfiles <- parfiles
    parfiles <- GetParFiles()   
	
    if(not ListEqual(prevparfiles,parfiles))
    {

       ##we need to update the pbox here.
       UpdatePulldown(psetbox,parfiles)  ##this takes 60+ ms on windows.
       pselected <- psetbox.selected

    }


    Draw()

   resp <-  WaitForButtonClickOnTarget(vals,returns)
   stmtmptime1 <- GetTime()

   
   tmp <- First(resp)
   click <- Second(resp)
   obj <- Third(resp)
   if(tmp==0)
    {
       ##anything coded 0 should be able to handle itself:
       Callfunction(obj.clickon,[obj,click])

    }elseif(tmp==1)  #Click was on the portal.
      {
	 stmTime0 <- GetTime()

         event <- ClickOnScrollbox(gPortal,gClick)
         newselected <- gPortal.selected

	 ##Most of the updates only matter if we did a selection action.
	 

	 if(event == "<select>")
	 {


          if(gselected == newselected)
	     {
		 
		 


             ##We are selecting something we just selected.open 
              ##directory
              if(IsDirectory(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
                {		

                  
                  gDirChain <- AppendDirlist(gDirChain,Nth(gFlatFileList,gselected))

	              gDirChainUpdated <- 1

	          if(Length(gDirChain)<(Length(selectstack)+1))
                    {	
    	              ##we are backing up. (i.e., ../ was clicked on)


	                   last <- Nth(selectstack,Length(selectstack))
                       gselected <- First(last)
                       gPortal.selected <- First(last)

		       ##the selected item may be beyond maxitems.
		       ##in this case, we need to update the offset.
                       if(gPortal.selected>gPortal.maxitems)
                         {
                           gportal.listoffset <- gPortal.selected-Floor(gPortal.maxitems/2)
                         }


   	             ##Remove the last item.
		      if(Length(selectstack)<=1)
                      { 
                       selectStack <- []
                      } else {
                        selectStack <-SubList(selectstack,1,Length(selectstack)-1)
	       	          }
       	   	          gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                     gDirChain,First(gFilters))
                      gFlatFileList <- Flatten(gfilelist)

                   }elseif(Length(gDirChain)>Length(selectstack))
                    {
                       ###############################
                       #We opened a new subdirectory.


                        selectStack <- Append(selectstack,[gselected, gOffset])
                  	pselected <- -1
        	        gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                  gDirChain,First(gFilters))
         	        gFlatFileList <- Flatten(gfilelist)
                       gselected <- gPortal.selected


                  } else {
		      gselected <- newselected
                  }


         }}}else{


	   ##update selection stuff.
	   gSelected <- newselected
	   newselected <- gPortal.selected
      }
	  

		if(gDirChainUpdated)
		  {
             list <- DirToText(First(gfilelist),Second(gfilelist),   
                             gDirChain)
          


             gPortal.list <- list



             UpdateScrollbox(gPortal)		
	   }

	   
       ##selected gets updated here;
       Draw(gPortal)


       gSelected <- gPortal.selected

       UpdateScreen(win)


	   #    Draw()

      }elseif(tmp==5) ##Exit
      {


           PushButton(exit,[0,0])
	   ExitPEBL(gWinDummy,click)

      }elseif(tmp==6) ##hit 'run'
      {
         PushButton(run,[0,0])
        if(not IsPEBLFile(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
         {		
	   PopUpMessageBox("Please select a .pbl file to run",win)
         } else {

	   ##it is a real PEBL test:
       	  if(gnimhdemographics)
    	  {
	      	  GetNIMHDemographics(gsubcode,win,"demographics-log.csv")
          }

	     paramindex <- psetbox.selected

	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{

  	         paramset <- Nth(psetbox.list,paramindex)
             }


             RunScript(gDirChain,Nth(gFlatFileList,gselected),
	                         gfullscreen,
                                 glanguage,logfile,gsubcode,
				 gexperimenter,paramset,gVSyncState)


             ReadSTDOutStdErr()
             UpdateStdOut(gWinDummy,click)
  	      Draw()

             

          if(gAutoSubCode)
           {
	      ##only do this if it survives a round-trip
               if(ToInteger(gSubcode)+""==gSubcode+"")
                {
 	          gSubCode <- (ToInteger(gSubCode)+1)
                  subjectbox.text <- gSubCode
                }
           }

          }
      }elseif(tmp==7)  ##Change subject code
      {
	   
       ##subject box
	   Show(subboxhighlight)
	   relx <- First(gClick) - (subjectbox.x )
	   rely <- Second(gClick) - (subjectbox.y )

	   subjectbox.cursorpos <-    (GetTextBoxCursorFromClick(subjectbox,relx,rely))

	   Draw()
	   gsubcode <- GetInput(subjectbox,"<return>",1)
           if(ToInteger(gSubcode)+""==gSubcode+"")
              {
 	          gSubCode <- ToInteger(gSubCode)
                  subjectbox.text <- gSubCode
               }

	   Hide(subboxhighlight)
	   
      }elseif(tmp==8)
      {
         ClickCheckBox(fullscreenbox,[0,0])
	 gfullscreen <- fullscreenbox.state

      }elseif(tmp==9)  ##Change experimenter code
      {
       ##experimenter box
	   Show(expboxhighlight)
	   relx <- First(gClick) - (expbox.x )
	   rely <- Second(gClick) - (expbox.y )
	   cursorpos <- GetTextBoxCursorFromClick(expbox,relx,rely)
	   expbox.cursorpos<-cursorpos
	   Draw()
	   experimenter <- GetInput(expbox,"<return>",1)
	   Hide(expboxhighlight)
	   
      }elseif(tmp==10)  ##Change language code
      {

       ##languagebox
	   Show(langboxhighlight)
	   relx <- First(gClick) - (langbox.x )
	   rely <- Second(gClick) - (langbox.y )
	   cursorpos <-  GetTextBoxCursorFromClick(langbox,relx,rely)
	   langbox.cursorpos <- cursorpos 
	   Draw()
	   gLanguage <- GetInput(langbox,"<return>",1)
	   Hide(langboxhighlight)
      }elseif(tmp==2)
      {	   
        ##experiment chain 
       CallFunction(chainbox.clickon,[chainbox,gClick])

      }elseif(tmp==3)
      {
      ##insert into chain.

	 PushButton(insertinchain,[0,0])


        ##filename
  	 fname <- Nth(gFlatFileList,gselected)

        ##label--set initially to fname
        label <- SubString(fname,1,StringLength(fname)-4)



	 if(IsPEBLFile(fname))
         {
	     paramindex <- psetbox.selected
	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{
  	         paramset <- Nth(psetbox.list,paramindex)
            }

	    selected <- Max([0,chainbox.selected-1])
            gExpChain <-  Insert(gexpchain,
                                 MakeChainEntry(gDirChain,label,fname,paramset),
				 selected)

	    
	    chainbox.list<-MakeExpChainList(gexpchain)

            UpdateScrollbox(chainbox)
            Draw(chainbox)
         }


      }elseif(tmp==4)
      {

      ##delete
       PushButton(deletestep,[0,0])

       selected <- Max([1,chainbox.selected])
       gExpChain <-  RemoveSubset(gexpchain,[selected])

       chainbox.list<-MakeExpChainList(gexpchain)
       chainbox.selected <- Min([chainbox.selected,chainbox.numitems])
       UpdateScrollbox(chainbox)
       Draw(chainbox)


      }elseif(tmp==11)  ##Add to end chain
      {

	 PushButton(addtochain,[0,0])
	 ##filename
  	 fname <- Nth(gFlatFileList,gselected)
	 label <- SubString(fname,1,StringLength(fname)-4)
	 if(IsPEBLFile(fname))
         {
	     paramindex <- psetbox.selected

	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{
	         paramset <- Nth(psetbox.list,paramindex)
            }

            PushOnEnd(gExpChain, MakeChainEntry(gDirChain,label,fname,paramset))

	    chainbox.list<-MakeExpChainList(gexpchain)
	    chainbox.selected <- Length(chainbox.list)
            UpdateScrollbox(chainbox)
            Draw(chainbox)
         }

	   
      }elseif(tmp==12)  ##clear chain
      {
	    PushButton(clearchain,[0,0])
            gexpchain <- []        
	    chainbox.list<-MakeExpChainList(gexpchain)
            UpdateScrollbox(chainbox)
            Draw(chainbox)

	   
      }elseif(tmp==13)  ##launch chain
      {
         PushButton(launchchain,[0,0])
	 if(gnimhdemographics)
	  {
              GetNIMHDemographics(gSubcode,win,"demographics-log.csv")
          }

          if(gRandomizeChain)
	  {
	    chain <- Shuffle(gexpchain)
	  } else{
            chain <- gexpchain
	  }

   	  loop(i,chain)
          {
  	    dc <- First(i)

	    ##the second argument is the human-readable label.
            fname <- Third(i)
	    psettext <- Fourth(i)
            RunScript(dc,fname,gfullscreen,glanguage,logfile,gsubcode,gexperimenter,psettext,gVSyncState)
          }
   
      ##Increment subject code after you run
      if(gAutoSubCode)
         {
               if(ToInteger(gSubcode)+""==gSubcode+"")
                {
 	          gSubCode <- (ToNumber(gSubCode)+1)
                  subjectbox.text <- gSubCode
                }

         }

      }elseif(tmp==14)  ##View debug output
      {

         PushButton(viewoutput,[0,0])
         file <- DirListToText(gDirChain)+"stdout.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }
      
      }elseif(tmp==15)  ##View error output
      {
         PushButton(viewerror,[0,0])
         file <- DirListToText(gDirChain)+"stderr.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }

      }elseif(tmp==16)  ##Edit script
      {
         PushButton(edit,[0,0])

	    file <- DirListToText(gDirChain)+Nth(gFlatFileList,gselected)
  	    if(FileExists(file))
	    {
              LaunchFile(gQuote+file+gQuote)
	    }else{
  	      PopupMessageBox("Unable to find file: ["+file+"]",win)
            }

      }elseif(tmp==17)  ##Open Manual
      {   
          PushButton(openmanual,click)
          OpenManual(gWinDummy,click)
        
      }elseif(tmp==18)  ##Launcher Size
      {
	 PushButton(launchsize,click)
	 ChangeLauncherSize(gWinDummy,click)

      }elseif(tmp==19)  ##Visit web
      {
         PushButton(visitweb,click)
         GoToWeb(gWinDummy,click)	   

      }elseif(tmp==20)  ##About
      {
	   PushButton(about,[0,0])
           AboutMessage(gWinDummy,click)



      } elseif(tmp==21) ##handle clickon the description
      {


        ClickOnScrollBox(gDescription,gClick)

      }elseif(tmp==22)
      {
            ClickCheckBox(demobox,[0,0])
            gnimhdemographics <- demobox.state

      }elseif(tmp==23)  ##SAVE CHAIN
      {
         PushButton(savechain,[0,0])
         Saveconfig(gconfigname)
         PopupMessageBox("Configuration file:" + gConfigName+ " saved.",win)
       }elseif(tmp==39)
       {  ##name chain button.
         PushButton(namechain,[0,0])
	 cname <- ""
	 
	 while(cname=="")
	 {
   	    cname <- PopUpEntryBox(gConfigNameText,win,gClick,gConfigname)
	 }
        if(not IsConfigFile(cname))
	{
          cname <- cname + ".config"
	}

         gConfigname <- cname
         Saveconfig(gconfigname)

          opts <- GetConfigFiles()
	  PushOnEnd(opts,gLoadChainText)
	  UpdatePullDown(loadchain,opts)

         ##try to select gConfigName:
        index <- 1
        loop(i,loadchain.list)
         {

        if(i == gConfigName)
         {
           loadchain.selected <- index
           DrawPulldown(loadchain)
         }
        index <- index + 1 
         }



         PopupMessageBox("Configuration file:" + gConfigName+ " saved to disk",win)

       } elseif(tmp==36)
      {  ##delete selected chain.
      
       PushButton(deletechain,[0,0])

       if(FileExists(gConfigName))
        {
          DeleteFile(gConfigName)
        }
 
          opts <- GetConfigFiles()
	  PushOnEnd(opts,gLoadChainText)
	  UpdatePullDown(loadchain,opts)
	  selected <-   Min([loadchain.selected,loadchain.numitems])
          gConfigName<-Nth(loadchain.list,selected)



     ##now, gconfigname is re-selected.
     ReadConfigFile(gConfigName)
     if(not FileExists(gConfigName))
       {
         Saveconfig(gConfigname)
       }

   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }


         ##fullscreen may have been changed when config was read in.

	SetCheckBox(fullscreenbox,gFullScreen)
	SetCheckBox(vsyncCheck,gVSyncState)
        SetCheckBox(demobox,gNIMHDemographics)
        SetCheckBox(randomizechainBox,gRandomizeChain)
        SelectPullDownByText(rendererbox,gDriver)
	title <- chainbox.header
	title.text <- gExpChainText+gConfigName
         chainbox.list<-MakeExpChainList(gexpchain)
         UpdateScrollbox(chainbox)
         Draw(chainbox)
 
      }elseif(tmp==24)  ##loadchain pulldown box
      {
          opts <- GetConfigFiles()
	  PushOnEnd(opts,gLoadChainText)
	  UpdatePullDown(loadchain,opts)
	  selected <-   Pulldown(loadchain,gClick)
	  if(selected == loadchain.numitems)
          {
            configname <- PopUpEntryBox(gConfigNameText,win,gClick,"")
	    if(not IsConfigFile(configname))
	     {
                configname <- configname + ".config"
	     }
            gConfigName<-configname

	    PushOnEnd(opts,gConfigname)
	    UpdatePulldown(loadchain,opts)	     
          }else{
            gConfigName <- Nth(loadchain.list,selected)
          }

         ##now, gconfigname is selected.
        ReadConfigFile(gConfigName)
        if(not FileExists(gConfigName))
        {
          Saveconfig(gConfigname)
        }

   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }


         ##fullscreen may have been changed when config was read in.

	SetCheckBox(fullscreenbox,gFullScreen)
	SetCheckBox(vsyncCheck,gVSyncState)
        SetCheckBox(demobox,gNIMHDemographics)
        SetCheckBox(randomizechainBox,gRandomizeChain)
        SelectPullDownByText(rendererbox,gDriver)
	UpdateScreenResPulldown(screenselection)
        DrawPulldown(screenselection)

	title <- chainbox.header
	title.text <- gExpChainText+gConfigName

         chainbox.list<-MakeExpChainList(gexpchain)
         UpdateScrollbox(chainbox)
         Draw(chainbox)
         

      }elseif(tmp==25)  ##Visit wiki
      {
        PushButton(wiki,[0,0])
        VisitWiki(gWinDummy,click)
        
      } elseif(tmp==26)
      { 
        ##increment!
          if(ToInteger(gSubcode)+""==gSubcode+"")
              {
                  gSubCode <- (ToNumber(gSubCode)+1)
                  subjectbox.text <- gSubCode
               }
   
	    PushButton(subplusbutton,[0,0])

      } elseif(tmp==27)
      { 

       ##Command-line box
	   relx <- First(gClick) - (clobox.x )
	   rely <- Second(gClick) - (clobox.y )

	   clobox.cursorpos <-  GetTextBoxCursorFromClick(clobox,relx,rely)
	   Draw()
	   gCommandLineText <- GetInput(clobox,"<return>",1)
	   Hide(cloboxhighlight)

      } elseif(tmp==28)
      { 

       PushButton(filter,[0,0])
       gFilters <- Rotate(gFilters,1)
       filter    <- MakeButton(First(gFilters),filter.x,filter.y,win,172)
       gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
       gFlatFileList <- Flatten(gfilelist)

       gPortal.list <-  DirToText(First(gfilelist),Second(gfilelist),   
                             gDirChain)

       UpdateScrollbox(gPortal)			     
       Draw(gPortal)
       UpdateScreen(win)



      }elseif(tmp==29)  ##29 == donate 
       {		
         PushButton(donate,[0,0])
 	 Launchfile("http://www.superiorideas.org/projects/open-source-psychology-software")

if(0)
{
	 fname <-DirListToText(gDirChain)+ Nth(gFlatFileList,gselected)

		 if(IsDataFile(fname))
         {

			bg1 <- Rectangle(550,400,700,800,MakeColor("black"),1)
			bg <- Rectangle(750,400,490,790,MakeColor("grey"),1)

			AddObject(bg1,win)			
			AddObject(bg,win)


			header <- EasyLabel("Transmit data file to server.",750,20,win,30)
			message <- EasyLabel("Enter IP address or hostname:",750,60,win,22)
			message2 <- EasyLabel("",750,80,win,22)
			
			entry <- EasyTextBox(gDefaultHostName,550,100,win,16,400,20)
                        address <- GetInput(entry,"<return>")
			gDefaultHostName <- entry.text
			Draw()



			text <- FileReadText(fname)

			message.text <-"Opening connection to host: "+address
			Draw()

			starttime <- GetTime()
			network <- 0
			message2.text <- "waiting"

			secs <- 0

			
			while(network==0 and secs < 10)
 			{

 	                   network <- ConnectToHost(address,4444)			     
			   time <- Floor((GetTime()-starttime)/1000)
			   
			  
			   if(time > secs)
			   {

			     secs <- time
                              message2.text <- message2.text + "."
			     Draw()
                            }
			}			

			if(network==0)
			{
			   message.text <- "Unable to make connection to host."
			   message2.text <- "Press any key to return."
			   Draw()
			} else {

			   message.text <- "Connected to host. Sending data."
			   Draw()

			    SendFile(network,fname,"USER"+RandomDiscrete(10000),message)
			    message.text <-  "Data sent."
 	  	 	    message2.text <- "Press any key to return."
             	            CloseNetworkConnection(network)
			}

			Draw()
			RemoveObject(bg1,win)
			RemoveObject(bg,win)
			RemoveObject(entry,win)
			RemoveObject(message,win)
			RemoveObject(message2,win)
			RemoveObject(header,win)

			WaitForAnyKeyPress()
          }


      	   Draw()

         } else {
           PopupMessageBox("Not implemented",win)
         }

		 
       } elseif(tmp==30) ##write review
        {
 	     PushButton(review,[0,0])
	     Launchfile("http://sourceforge.net/projects/pebl/reviews/")
	   
       }elseif(tmp==31)  ##Change screen resolution.
         {       



          resolutions <- UpdateScreenResPulldown(screenselection)
	  PullDown(screenselection,gClick)
	  Draw()
        choice <- screenselection.selected ##index chosen.

        ##choice could be any one of the first N
	##options, 'current', 'custom'

       if(choice ==screenselection.numitems)
	   {
	     ##get custom screen size:

	      xy <- [screenselection.x+screenselection.width/2,
                      screenselection.y+screenselection.height/2]

              width <- ToNumber(PopUpEntryBox(gGetWidthText,win,xy,""))
              height <- ToNumber(PopUpEntryBox(gGetHeightText,win,xy,""))
	      gCustomScreenRes <-  width+"x"+height
              UpdateScreenResPulldown(screenselection)
	      ##reset to choice

	      screenselection.selected <- screenselection.numitems-1

	      DrawPulldown(screenselection)	      
	      gScreenRes <- gCustomScreenRes	      
	      Draw()

	   } elseif(Nth(screenselection.list,choice) == gCurrent   or
	           Nth(screenselection.list,choice) == (gCurrent+"*"))
	   {
             ##Use the current screen resolution:
 	     gScreenRes <- gCurrent

	   } elseif(Nth(screenselection.list,choice)== (gCustomText+gCustomScreenRes)){
	    gScreenRes <- gCustomScreenRes

           }else {
	      #Use the specified resolution.
	      res <- Nth(resolutions,choice)
	      ##this occasionally crashes for some reason because
	      ## res=="Current" and not a list.

              gScreenRes <- First(res)+"x"+Second(res)

   	   }

         

     }elseif(tmp==32)
      {
       ClickCheckBox(randomizechainbox,[0,0])
       gRandomizeChain <- randomizechainbox.state

      }elseif(tmp==33)
      {
       ##Set/edit parameters. 
       PushButton(params,[0,0])

        paramindex <- psetbox.selected
        if(paramindex==0 or Length(psetbox.list)==0)
         {
             paramset <- "default"
          }else{
             paramset <- Nth(psetbox.list,paramindex)
          }
          file <-  SetParameters(gDirChain,Nth(gFlatFileList,
                                      gselected),win,paramset)

       ## we need to update psetbox and select file if it exists.
          parfiles <- GetParFiles()   

          UpdatePulldown(psetbox,parfiles)

	  ##find out best index.
	  if(Length(parfiles)>0)
          {
	  loop(i, Sequence(1, psetbox.numitems,1))
	  {

	   if(Nth(psetbox.list,i)==file)
           {
             psetbox.selected <- i
	     break
           }
	  } 
          }
          pselected <- psetbox.selected
	  DrawPulldown(psetbox)

     } elseif(tmp==34)
      {
        ##Combine data dialog, which is really a separate PEBL program.
        PushButton(combineData,[0,0])
        CombineDataDialog(gDirChain,Nth(gFlatFileList,gselected),logfile)
      }elseif(tmp==35)
      {
       ##get the parameter files we want.

       if(Length(parfiles)>1)
       {
        Pulldown(psetbox,gClick)
        pselected <- psetbox.selected
       }



     }elseif(tmp==37)
      {
 
       ##Set/edit parameters. 
       PushButton(makelauncher,[0,0])
       if(not gPasswordEntered) 
       {
         PopUpMessageBox("This version of the PEBL launcher cannot create a custom launch sequence.  Please donate to the PEBL project to use the custom launcher creator.",win)
       }else{


         ##Create custom applescript bundle by making folders/copying base files.
        if(GetSystemType()=="OSX")
        {

            dir <- "$HOME/Documents/pebl-exp."+gPEBLVersion+"/"
            launchername <- dir + "Launch "  +gConfigName + ".app"
          
          fileout <- FileOpenOverwrite("/tmp/tmp.scpt")
          scripttext <- "do shell script "+gQuote+"cd "+dir+"; mkdir logs; /Applications/PEBL2.app/Contents/MacOS/PEBL2 customlauncher.pbl -v " + gConfigName +   " > logs/"+gConfigName+"-stdout.txt " + " 2> logs/"+gConfigName+"-stderr.txt"+ gQuote 
          FilePrint(fileout,scripttext)
          FileClose(fileout)

          SystemCall("/usr/bin/osacompile -c PEBL -o "+gQuote +launchername + gQuote + " /tmp/tmp.scpt","")

          SystemCall("cp " +  gPEBLResourcePath + "/AppIcon.icns " + gQuote+launchername+"/Contents/Resources/applet.icns" + gQuote)
# DeleteFile("/tmp/tmp.scpt")


        } elseif(GetSystemType()=="WINDOWS")
	{


       if (gUseReloc)
	    {

                batfiletext <- "md logs
set ABSPATH=%CD%
START /B %ABSPATH%\PEBL\bin\pebl2.exe customlauncher.pbl -v "+ gConfigName+"  > logs\launchlog.txt 2> logs\launcherrors.txt"
            } else{

    
               batfiletext <- "md logs"+CR(1)+
              gPEBLName +" customlauncher.pbl -v "+ gConfigName+"  > logs\launchlog.txt 2> logs\launcherrors.txt"
            }

	 batfile <-  FileOpenOverwrite("Launch " + gConfigName+".bat")
	 FilePrint(batfile,batfiletext)
	 FileClose(batfile)
     } elseif(GetSystemType()=="LINUX")
     {

 dir <- "$HOME/Documents/pebl-exp."+gPEBLVersion+"/"
desktoptext <- "[Desktop Entry]
Version=2.0

Name=Run PEBL 2 "+gConfigName+"
Exec=bash -c 'cd "+gquote+"$HOME/Documents/pebl-exp.2.0"+gquote+" && pebl2 customlauncher.pbl -v default.config'
Terminal=false
Type=Application
Icon="+gPEBLResourcePath +"/media/images/pebl2.png
StartupNotify=true"

           fname <- "Launch " + gConfigName+".desktop"
           filee <- FileOpenOverwrite(fname)
	   FilePrint(filee,desktoptext)
	   FileClose(filee)
           SystemCall("chmod u+x "+gQuote +fname +gQuote,"" )
    
     }
	 PopUpMessageBox("Launcher for " +gConfigName+ " created in Documents\pebl-exp.X",win)
       }
      }elseif(tmp==38)
      {

       PushButton(translatetest,[0,0])
       file <- Nth(gFlatFileList,gselected)
       filewithpath <- DirListToText(gDirChain) + file
       EditTranslation(gDirChain,file,gLanguage,logfile)

#        runtext <- "translatetest.pbl -v " + file 
#       RunScript(gdirchain, runtext,0,gLanguage, logfile,0,"","")

     }elseif(tmp==40)
     {
          
        ClickCheckBox(vsyncCheck,[0,0])
        gVSyncState <- vsyncCheck.state
	
     }elseif(tmp==41)
     {
	  PullDown(rendererbox,gClick)
	  gDriver <- Nth(rendererbox.list,rendererbox.selected)
          #Print("driver selected:" + gDriver)
	  
     }


	# Print(GetTime()+"outer draw")
	# Print("         Timing:  " + (GetTime()-stmtmptime1))
  
     #Draw()

   }  ## end of main loop.


}


define EditTranslation(dirChain,filename,language,logfile)
{

 ##this would work, but it runs blocking the current app. so reconstruct runscript.

   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {

        sep <- CR(1)
        gPEBLName <- "\bin\pebl2.exe"  ##The relative location should be bin\pebl2.exe
  	    callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL" +gPEBLName +gQuote + " " +  gQuote + "translatetest.pbl"+gQuote+ "  -v " + filename

     }else {
         
  	      callstring <- "cd " + DirListToText(dirChain) + sep  + gPEBLName + " translatetest.pbl -v " + filename

            }

     callstring <- callstring + " --language " + glanguage 

     if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
        {
          if(gDebug)
	    {
             if(type == "WINDOWS")
	        {
  		      callstring <- callstring + "> combine.out.txt 2> combine.err.txt "
		    }
             }

	   if(type=="LINUX" or type=="OSX")
             {

                callstring <- callstring + " > stdout.txt 2> stderr.txt "
             }
        }

	##be sure to run in background, if possible.
  callstring <- callstring + "&"  ##Run in background
  if(0)#gUseReloc)
      {
         runfile <- FileOpenOverWrite("tmp.bat")
         FilePrint(runfile,callstring)
         FileClose(runfile)
         SystemCall("tmp.bat","")

      }else{
         #PopUpMessageBox(callstring,gwin)
         Print(callstring)
         Print(SystemCall(callstring,""))
      }
}




define CombineDataDialog(dirChain,filename,logfile)
{
 ##this would work, but it runs blocking the current app. so reconstruct runscript.
##  RunScript(dirchain, "combinedatafiles.pbl",0,gLanguage, logfile,0,"","")
## gDebug <- 1

   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {

        sep <- CR(1)
        gPEBLName <- "\bin\pebl2.exe"  ##The relative location should be bin\pebl2.exe
  	    callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL" +gPEBLName +gQuote + " " +  gQuote + "combinedatafiles.pbl"+gQuote

     }else {
         
  	      callstring <- "cd " + DirListToText(dirChain) + sep  + gPEBLName + " "  +gQuote+ "combinedatafiles.pbl"+gQuote 

      }

     callstring <- callstring + " --language " + glanguage 

     if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
        {
          if(gDebug)
	    {
             if(type == "WINDOWS")
	        {
  		      callstring <- callstring + "> combine.out.txt 2> combine.err.txt "
		    }
             }

	   if(type=="LINUX" or type=="OSX")
             {

                callstring <- callstring + " > stdout.txt 2> stderr.txt "
             }
        }

	##be sure to run in background, if possible.
  callstring <- callstring + "&"  ##Run in background
  if(gUseReloc)
      {
         runfile <- FileOpenOverWrite("tmp.bat")
         FilePrint(runfile,callstring)
         FileClose(runfile)
         SystemCall("tmp.bat","")

      }else{
         #PopUpMessageBox(callstring,gwin)
         Print(callstring)
         Print(SystemCall(callstring,""))
      }
}




##This is a hard-coded filter;
##it will only return .pbl files and directories.
define FilterDir(inlist,path,type)
{

  pathhead <- DirListTotext(path)
  tmpdir <- []
  tmppbl <- []
  loop(i, inlist)
  {

    if(IsDirectory(pathhead+i))
      {
         tmpdir <- Append(tmpdir,i)
      }else{
	  
       if(type=="*.pbl")
       {
       if(IsPEBLFile(i))
        {
            tmppbl <- Append(tmppbl,i)
        }
       } elseif(type=="data files") {
         if(IsDataFile(i))
         {
	     tmppbl <- Append(tmppbl,i)
         }
	        
      }elseif(type=="*.*"){
	   ##no filter:
           tmppbl <- Append(tmppbl,i)
       }elseif(type=="*.png")
       {
         if(IsPNGFile(i))
	 {
           tmppbl <- Append(tmppbl,i)
	 }
       }elseif(type=="*.par")
       {
        if(IsPARFile(i))
	{
          PushOnEnd(tmppbl,i)
	}
       }elseif(type=="*.config")
       {
         if( IsConfigFile(i))
	 {
	   PushOnEnd(tmppbl,i)
	 }
       }elseif(type=="*.about.txt")
       {
         if(IsAboutFile(i))
         {
          PushOnEnd(tmppbl,i)
         }

       }
     }
  }


  return [Sort(tmpdir),Sort(tmppbl)]

}



define DirToText(dirlist,filelist,path)
{ 
  timeStart <- GetTime()
  tmp1 <- ModList(dirlist,"","\")
  tmp <- Merge(tmp1,filelist)

 return tmp
}


define AppendDirList(dirlist,dir)
{

 if(dir == ".")
   {
     dirlist <- dirlist
   }elseif(not dir == "..")   
   {
      dirlist <- Append(dirlist,dir)
   } else {
      if((not Last(dirlist) == ".") and
	     (not Last(dirlist) == ".."))
	  {
	      dirlist <- SubList(dirlist,1,Length(dirlist)-1)
      } else {
	      dirlist <- Append(dirlist,dir)
      }
   }

   return dirlist
}


##appends a set of nested directories into a path.
define DirlistToText(list)
{

  if(GetSystemType()=="WINDOWS")
    {
	   sep <- "\"
	} else {
	   sep <- "/"

	}
    out <- ListToString(list,sep) + sep
    return out
}


##This saves a table (nested list) to a file
##it is used to save the .config files
define  FileSaveTable(table,filename)
{

   ##Not clear why we are using global here rather than the passed-in value.

   outfile <- FileOpenOverwrite(filename)  ##Overwrite whatever we ave, without checking for it.
   loop(i,table)
    {
       FilePrint_(outfile, First(i) + ",")

	   if(IsList(Second(i)))
        {
		   sep <- ""
		   loop(j,Second(i))
           {
		      FilePrint_(outfile,sep+j)
			  sep <- ","
           }
		   FilePrint(outfile,"")
        } else {
		  FilePrint(outfile,Second(i))
        }
    }
  FileClose(outfile)
}


##This makes the text to put in the expchain box.
define MakeExpChainList(expchain)
{
  tmp <- []
  loop(i,expchain)
    {
 
       PushOnEnd(tmp,Second(i))
    }
  return tmp	
}


define RunScript(dirChain,filename,fullscreen,language,logfile,subcode,experimenter,pset,vsync:0)
{

  ##Additional command-line parameters that should be hardcoded:
  ## put --driver  --video, etc. here. 
  gCommandLineAdd <- " " + gCommandLineText

   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {

        sep <- CR(1)
        gPEBLName <- "\bin\pebl2.exe"  ##The relative location should be bin\pebl2.exe
		callstring <- "echo on "+sep+"set ABSPATH=%CD%"+sep+ 
		              "set PEBL="+gQuote+"%ABSPATH%\PEBL\bin\pebl2.exe"+ gQuote+sep +
					   "cd "+gQuote+"%ABSPATH%\" + DirListToText(dirchain) + gQuote+sep + 
					   "START /B "+gQuote + "PEBLTITLE" + gQuote+" %PEBL% " +filename + " -s " + subcode 

     }else {
         
		  ##  MessageBox("calling:" + gPEBLName ,gWin)
			
    		 callstring <- "cd " + gQuote+DirListToText(dirChain)+gQuote + sep  +
                                gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode
##    		 callstring <-  gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode


      }


      ##Get the current screen size to use for launching experiments,
      ##the preferred size should be set or read in from config file.
      ## if we are not fullscreen.
     if(gScreenRes == gCurrent)
      {
        gScreenResLine <- ""
      }else  {
        gScreenResLine <- "--display " + gScreenRes
      }
       
      if(vsync)
       { 
          gScreenResLine <- gScreenResLine + " --vsyncon "
       }

       if(fullscreen)
         {
	     callstring <- callstring + " --fullscreen " + gScreenResLine

         }else{
              ##If not fullscreen, use something sligtly smaller
              ##to make way for toolbars etc.
             callstring <- callstring + " " + gScreenResLine
          }

	  if(not pset == "")
           {
             callstring <- callstring + " --pfile " +gQuote+ pset+gQuote
           }

	    callstring <- callstring + " --language " + language  + " " + gCommandLineAdd
  

          if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
           {
            if(gDebug)
  	       {
		  if(type == "WINDOWS")
		    {
			   callstring <- callstring + sep+"pause"
		    }
                }
               callstring <- callstring + " > stdout.txt 2> stderr.txt"

           }

         FilePrint(logfile,TimeStamp() + "," + DirListToText(dirChain)+ filename+","+GetPEBLVersion() + "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"STARTED")

         #### Run the experiment!!!!
         Print("Executing : [" + callstring + "]")

  if(gUseReloc)
      {

          runfile <- FileOpenOverWrite("tmp.bat")
     ##     FilePrint(runfile,callstring+sep+"pause") ##Use for debugging purposes.
          FilePrint(runfile,callstring)
          FileClose(runfile)
          SystemCall("tmp.bat","")
      }else{
	      #MessageBox(callstring,gWin)
          Print(SystemCall(callstring,""))
      }

         FilePrint(logfile,TimeStamp() + "," + DirListToText(gDirChain)+filename+","+GetPEBLVersion() +
		 "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"FINISHED")

		 
           Draw()
		 }



define IsPEBLFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".pbl")
	     			{
					  returnval <-  1
                    }

          }
   return returnval
}

define IsparFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".par")
		{
			  returnval <-  1
                 }

          }
   return returnval
}


define IsConfigFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>6)	
      {
       if(SubString(fname,len-6,len)==".config")
	  {
           returnval <-  1
          }

          }
   return returnval
}

define IsAboutFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>9)	
      {
       if(SubString(fname,len-9,len)==".about.txt")
	  {
           returnval <-  1
          }

          }
   return returnval
}

define IsDataFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
		   tmp <- SubString(fname,len-3,len)
            if(tmp==".csv" or tmp == ".dat" or tmp == ".txt") 
    			{
					  returnval <-  1
                }

          }
   return returnval
}

define IsPNGFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
           if(Lowercase(SubString(fname,len-3,len))==".png")
	     	{
					  returnval <-  1
                }

          }
   return returnval
}





define ReadConfigFile(configname)
{
   ##This reads in some configuration stuff from the current
   ## config file.
   configfname <- "configfiles/"+configname

   if(FileExists(configfName))
      {
           config <- (ReadCSV(configfname))
	   
	   ##read in the keys--first characters.
	   keys <- []
	   loop(i,config)
	   {
	     keys<- Append(keys,First(i))
           }

	   tmpres <- First(gScreenResInitial)+"x"+Second(gScreenResInitial)
           ##This is the text description of the screenres.
	   gScreenRes <- GetConfig("screenres",keys,config,tmpres)
	   ##we need to set the pulldown default here.
	   
	   gfullscreen <- ToNumber(GetConfig("fullscreen",keys,config,0))
	   gnimhdemographics <- ToNumber(GetConfig("nimhdemo",keys,config,0))
	   gsubcode    <- GetConfig("subcode",keys,config,"0")

	   if(gAutoSubCode)
            {
             if(ToInteger(gSubCode)+""==gSubcode+"")
             {
  	         gSubCode <- (ToInteger(gSubCode)+1)
             }
            }


	   gDefaultHostName <- GetConfig("ipaddress",keys,config,"localhost")
	   gCommandLineText <- GetConfig("commandline",keys,config,"")
	   gexperimenter <-GetConfig("experimenter",keys,config,"default")
	   glanguage <-GetConfig("language",keys,config,"en")
	   gVSyncState <- ToNumber(GetConfig("vsync",keys,config,0))
           gDriver     <- GetConfig("driver",keys,config,"")
	   gRandomizeChain <- ToNumber(GetConfig("randomizechain",keys,config,0))
   	   gexpchain <- []         ##sequence of experiments to run
   	   ##Get all config entries named 'expchain'
	   chains <- Filter(config,Match(keys,"EXPCHAIN"))
	   loop(i,chains)
            {

             ##we need to extract
               #4+1  dirchain path (variable length so saved last) #1
               #1+1. human label (at end) #2
	       #2+1. script file name,     #3
               #3+1. parameter file,       #4

              PushOnEnd(gexpchain, 
                
                  MakeChainEntry(SubList(i,5,Length(i)),
                            Second(i),Third(i),Fourth(i)))

            }  

      } else {
      ##We don't have a config file.
        gDefaultHostName <- "localhost"
        gCommandLineText <- ""
        gfullscreen <- 0
        gVSyncState <- 0
        gDriver <- ""
        gsubcode <- "1"
        gexperimenter <- "default"
        glanguage <- "en"
  
        gexpchain <- []         ##sequence of experiments to run
	    gnimhdemographics <- 0
        gScreenRes <-  First(gScreenResInitial)+"x"+Second(gScreenResInitial)
	    gRandomizeChain <- 0
      }

}

define Saveconfig(configname)
{

    ##save settings on exit.
	out <- [["fullscreen",gfullscreen],
                ["subcode",gsubcode],
                ["experimenter",gexperimenter],
	        ["language",glanguage],
	        ["nimhdemo",gnimhdemographics],
	        ["commandline",gCommandLineText],
	        ["ipaddress",gDefaultHostName],
 	        ["screenres",gScreenRes],
		["driver",gDriver],
		["vsync",gVSyncState],
		["randomizechain",gRandomizeChain]
               ]
            

	  ##each element of gExpChain has three parts:
	  ##1. a list containing the path chain (variable length)
          ##2. the script name
 	  ##3. the parameter file (could be 'default')

	  loop(i,gexpchain) 
          {

             ##we need to save 
                    #1. human label (at end) #2
	            #2. script file name,     #3
                    #3. parameter file,       #4
                    #4  dirchain path (variable length so save last) #1

	     ilist <- Flatten([Second(i),Third(i),Fourth(i),First(i)])

	     PushOnEnd(out,["EXPCHAIN",ilist])
           }
      FileSaveTable(out,"configfiles/"+configname)
}




define GetStrings(lang)
{
       gRunText <- "Run selected test"
       gEditParams <- "Edit"

	gOpenText <- "Open/Edit Selected"
	gExitText <- "EXIT"
	gViewDebugText <- "Open debug output"
        gViewErrorText <- "Open error output"
        gCombineDataText <-"Combine data"
        gMakeLauncherText <- "Create custom launcher"
        gTranslateTestText <- "Translate test"
        gAddToChainText <- "Append"

	gInsertChainText <- "Insert"
	gDeleteStepText <- "Delete step"

	gClearChainText <- "Clear"
	gSaveChainText <- "Save"
        gNameChainText <- "Rename"
	gDeleteChainText <- "Delete Chain"
	gLoadChainText <- "Make New Chain"
        gRandomizeChainText <- "Randomize Chain"

	gOpenManualText <- "Open Manual"
	gAboutLabelText <- "About"
	gSizeText <- "Size: "
	gwebtext <- "Visit Website"
	gWikiText <- "Wiki"
	gLaunchChainText <- "Launch Chain"
    gNoDesc <- "Please cite PEBL if you use it:"+CR(1)+"Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods, 222, 250–259."
    gPEBLTitle <- "PEBL Launcher for "
    gPartCode <- "Participant Code:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gGetWidthText <- "Enter custom width in pixels:"
    gGetHeightText <- "Enter custom height in pixels:"
	gExperCode <- "Experimenter:"
	gCommandLineOptions <- "Command line:"
	gParameterLabel <- "Parameters:"
	gLangcode  <- "Language:"
	gFulltext <- "Fullscreen"
	gCollectDemoText <- "Collect demographics"
    gScreenResLabel <- "Screen size:"
    gVSyncText <- "Vsync"
    gExpChainText <- "Experiment Chain:"
    gConfigNameText <- "Enter name of new chain config file."
    gRelaunchMessage <- "Please exit the launcher and restart."
    gChooseScreenText <- "Choose screen resolution to use"
    gAboutText <-"PEBL is a system for creating and running psychology experiments.  It is developed by Shane T Mueller, Ph.D., and includes more than 50 standard psychology lab experiments.  You can use PEBL to create your own tests or modify previous ones FREE OF CHARGE. Find out more at http://pebl.sf.net

This launcher is written in PEBL itself, allowing a fairly uniform launcher on all platforms. Only .pbl  files and directories are shown in the file window--use your file manager to get the data after your experiment is complete. Click on a directory that has been selected to open it.  Add scripts to the experiment chain window to run a sequence of experiment in a row, all using the same subject code.  

 *The file [PEBLLaunch-log.txt] contains a log of every experiment launched from the launcher.
 *Debug output from each script (using the Print() command) is saved in the file [stdout.txt] file in a script's directory.
 *Error and automatic messages from each script are saved in the file [stderr.txt] in a script's directory."

   gScreenshotTextOn <- "Screenshots are now enabled. If the screen seems slow at updating, try turning screenshots off."
   gScreenshotTextOff <- "Screenshot previews are now disabled.  This may be useful if the launcher seems slow at updating."

  lang <- Uppercase(lang)
  if(lang == "ES")
   {
    gRunText <- "Ejecutar script seleccionado"
    gOpenText <- "Abre"
    gExitText <- "EXIT"
    gViewDebugText <- "Ver la salida de depuración"
    gViewErrorText <- "Ver la salida de error"
    gCombineDataText <-"Combinar data"
    gAddToChainText <- "Añadir a la cadena"
    gClearChainText <- "Borrar la cadena"
    gSaveChainText <- "Guardar la cadena"
    gLoadChainText <- "Cadena de carga nuevo"
    gOpenManualText <- "Abrir Manual"
    gAboutLabelText <- "Acerca de"
    gSizeText <-"Size: "
    gwebtext <- "Página Web"
    gWikiText <- "Wiki"
    gLaunchChainText <- "Lanzamiento de la cadena"
    gNoDesc <- "La descripción no encontrado"
    gPEBLTitle <- "PEBL Launcher para "
    gPartCode <- "Código de Participante:"
    gExperCode <- "Experimentador"
	gCommandLineOptions <- "Command line options:"
    gLangcode <- "Idioma:"
    gFulltext <- "Pantalla Completa"
    gScreenResLabel <- "Screen resolution:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gCollectDemoText <- "Recoger datos demográficos?"
    gChooseScreenText <- "Choose screen resolution to use"
    gExpChainText <- "Experimento de la cadena:"
    gConfigNameText <- "nombre de configuración?"
    gRelaunchMessage <- "Please exit the launcher and restart."
    gAboutText <- "Spanish Translation courtesy automated translation. PEBL es un sistema de creación y ejecución de experimentos de psicología Es desarrollado por Shane T Mueller, Ph.D., e incluye más de 50 experimentos de laboratorio estándar de la psicología Puede utilizar PEBL para crear sus propias pruebas o modificar la anterior. los GRATUITO. Más información en http://pebl.sf.net

Este lanzamiento está escrito en PEBL sí mismo, permitiendo que un lanzador bastante uniforme en todas las plataformas. . Sólo los archivos y directorios pbl se muestran en la ventana del archivo - utilizar su gestor de archivos para obtener los datos después de la prueba se ha completado. Haga clic en un directorio que ha sido seleccionada para abrirlo. Agregar secuencias de comandos a la ventana de la cadena de experimento para ejecutar una secuencia de experimentos en una fila, todas ellas con el código mismo tema.

 * El archivo [PEBLLaunch-log.txt] contiene un registro de todos los experimentos en marcha del lanzador.
 * La salida de depuración de cada secuencia de comandos (usando la Print() comando) se guarda en el archivo el archivo [stdout.txt] en el directorio de un script.
 * Mensajes de error y automática de cada secuencia de comandos se guardan en el archivo [stderr.txt] en el directorio de una secuencia de comandos."

   }
}



define CitePEBL(obj,click,extra:0)
{
    PopUpMessageBox("PEBL Can be cited as: Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods, 222, 250-259. A web browser should open to the sciencedirect page for this article",obj.win)
   Launchfile("http://www.sciencedirect.com/science/article/pii/S0165027013003762")

}


## This should be received with ReceiveText(network)
define SendText(network,text)
{
   len <- StringLength(text)
   
#   Print("Sending: [" + ZeroPad(len,10)+"]")

   SendData(network,ZeroPad(len,10))
   SendData(network,text)
   
}


define ReceiveText(network)
{
	len <- ToNumber(GetData(network,10))
	text <- GetData(network,len)
	return text
}


## a robust version of lookup:
define GetConfig(key, keys, database,empty)
{
   line <- Lookup(key,keys,database)
   if(Length(line)==0)
   {
    ret <- empty
   }else{
   ret <- Second(line)
   }
  return ret
}






## This sends a file using a direct tcp/ip connection, using
## a special file protocol.
##

define SendFile(network,filename,id,label)
{ 

   text <- FileReadText(filename)
   length <- StringLength(text)+""
   
   if(StringLength(length)>16)
   {
     SignalFatalError("Cannot send a file this long:"+length)
   }


   message <-  Format(id,32)+Format(length,16) + text
   label.text <-"Attempting to send data to server (up to 10 secs)"
   Draw()
   Wait(500)
   success <- SendData(network,message)
   if(success)
   {
      label.text <- "Succeeded at sending data"
      Draw()
      Wait(500)
   } else {
      label.text <- "Failed to send data.  Please try again later or send data files directly. Press any key to begin."
      Draw()
      WaitForAnyKeyPress()
   }
   return success
}

##  This is the installer code that gets run if the right Documents 
##  directory does not exist.
##  Otherwise, the normal launcher will run.
##
define RunFirstTime(p)
{
#    Print("running first time inside")
  
   if(Length(p)>1)
     {
	
   	 resources <- Nth(p,1)
	 targetdir <- Second(p)
	 home <- targetdir

	} else {
    	 #Print("using default resources")
   	    if(GetSystemType()=="OSX")
		  {
          #   Print(p)
   	         resources <- Nth(p,1)
          #   Print("Resources:" + resources)
	         
	         #resources <- "/Applications/pebl.app/Contents/Resources"

  		  } elseif(GetSystemType()=="WINDOWS")
            {
			
			##This hard-coded path is probably not ideal, because it assumes installation in programfiles but
			##some organizations may try to put this elsewhere:
			## IF YOU ARE A SYSADMIN WHO IS TRYING TO INSTALL ACROSS YOUR SYSTEM, THIS MAY BE A GOOD PLACE TO HARD-COD
			## A PATH WHERE PEBL LIVES ON YOUR NETWORK:
            ##Check here for robustness.
            if (FileExists("%ProgramFiles(x86)%"))
 		     {
		       resources <- "%ProgramFiles(x86)%\\PEBL2"
		      } else {

		       resources <- "%ProgramFiles%\\PEBL2"
		      }

		  }else {
		   ##linux.  this is hardcoded right now, but should be
		   ##made more portable:
		   resources <- "/usr/share/pebl"
		   if(not FileExists(resources))
		   {
  		     resources <- "/usr/local/share/pebl"
		   }

		   if(not FileExists(resources))
		   {
  		     resources <- "../"
		   }
		   

		   if(not FileExists(resources))
		   {
 		     SignalfatalError("Unable to find installed PEBL resource directory")
		   }
		   
        }

	 }

	if(0)
	 {
     ##We possibly need to hard-code this.
   
       if(GetSystemType()=="OSX")
	  {
           resources <- "/Applications/pebl.app/Contents/Resources"
      }
     }
	 
	 targetDir <- "pebl-exp."+gPEBLVersion
	
	
    gVideoWidth <- 800
    gVideoHeight <- 500
    gwin <- MakeWindow("white")
    gSleepEasy <- 1
       
   head1 <- EasyLabel(GetPEBLVersion() + " for " +GetSystemType(),gVideoWidth/2,50,gwin,22)


   pebl <- MakeImage("pebl.png")
   AddObject(pebl,gWin)
   Move(pebl,gVideoWidth/2,125)
   message0 <- "Resources at: ["+resources+"]" +CR(1)+ "HOME at: " + ghome + CR(1)
   message1 <- message0+"By default, PEBL tries to look for files in ["+ghome+"]" + CR(2) +
   "Would you like to create the directory and install some basic experiment scripts?"



   inst <- EasyTextBox(message1,
                        25,200,gwin,15,gVideoWidth-50,200)


if(1)
 {
   yes <- EasyLabel("YES", gVideoWidth/2-50,350,gWin,40)
   no <-  EasyLabel("NO",  gVideoWidth/2+50,350,gWin,40)
   Draw()
   copy <- WaitForClickOnTarget([yes,no],[1,0])
   Hide(yes)
   Hide(no)
 
 
    Draw()
 
     if(copy)
       {
	 if(GetSystemType()=="OSX")
	  {
	  SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion,"")
      SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+"/logs","")
      SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+"/configfiles","")
      SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+"/params","")

	#  SystemCall("cp "+resources+"/fileselect.pbl $HOME/Documents/pebl-exp."+gPEBLVersion+"/","")
      inst.text <- inst.text + CR(1) + "Copying battery";Draw()
 	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/battery","")
      inst.text <- inst.text + CR(1) + "Copying demos";Draw()


      Print("cp -R "+resources+"/demo/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ")

	  SystemCall("cp -R "+resources+"/demo/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ","")
      SystemCall("cp -R "+resources+"/experiments/* $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ","")
      inst.text <- inst.text + CR(1) + "Copying tutorials";Draw()


      Print("cp -R "+resources+"/tutorials/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/tutorials ")

      SystemCall("cp -R "+resources+"/tutorials/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/tutorials ","")

    # Print("cp "+resources+"/PEBLManual"+gPEBLVersion+".pdf $HOME/Documents/pebl-exp."+gPEBLVersion+"/")
      SystemCall("cp "+resources+"/PEBLManual"+gPEBLVersion+".pdf $HOME/Documents/pebl-exp."+gPEBLVersion+"/","")
      inst.text <- inst.text + CR(1) + "Done copying files";Draw()



###########copy files on windows

       }elseif(GetSystemType()=="WINDOWS"){


      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"
	    } elseif (FileExists(ghome+"\My Documents"))
		{
		   doc <- "\My Documents"
		} else {
		    #user-selected?
		    doc <- "\My Documents"
		}
		
            dest <- ghome+ doc + "\pebl-exp."+gPEBLVersion 
 	    #SystemCall("md " + dest +" >> "gHome+"\pebl_install_log.txt","")
         inst.text <- "Creating directories."; Draw()

        MakeDirectory(dest)
        MakeDirectory(dest+"\battery")
  	    MakeDirectory(dest+"\demo")
        MakeDirectory(dest+"\logs")
		MakeDirectory(dest+"\configfiles")
        MakeDirectory(dest+"\tutorials")

         inst.text <- "Copying battery.  This may take a while to complete. Do not close window.  "; Draw()

	 ##copy test battery:
        #  Print("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e")
   	  SystemCall("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e","")
        ##Copy demo:
		 inst.text <- "Copying demos."; Draw()

       # Print("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e")
        SystemCall("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e","")

		inst.text <- "Copying tutorials."; Draw();Draw()

        SystemCall("xcopy "+gQuote+resources+"\tutorials\*"+gQuote+" "+gQuote+dest+"\tutorials"+gQuote+" /e","")

        ##Copy doc:
        #Print("copy "+gQuote+resources+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote+" "+gQuote+dest+gQuote)
        SystemCall("copy "+gQuote+resources+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote+" "+gQuote+dest+gQuote,"")
		 inst.text <- "Copying complete. Click screen to continue."; Draw()


       }elseif(GetSystemType()=="LINUX"){

        ##################################################
	###########      copy files on linux

      resources <- gPEBLResourcePath
      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"/Documents"))
       {
	   doc <- "/Documents"
       } 

	
            dest <- ghome+ doc + "\pebl-exp."+gPEBLVersion
            MakeDirectory(dest)
	    MakeDirectory(dest+"/battery")
	    MakeDirectory(dest+"/demo")
            MakeDirectory(dest+"/configfiles")
	    MakeDirectory(dest+"/logs")


         inst.text <- "Creating directories."; Draw()

	  SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion,"")
          SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+"/logs","")
          SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+"/configfiles","")

          Print("copying resources:" + resources )
	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/battery","")
	  SystemCall("cp -R "+resources+"/demo/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ","")

      SystemCall("cp -R "+resources+"/tutorials/* $HOME/Documents/pebl-exp."+gPEBLVersion+"/tutorials ","")

          # Print("cp "+resources+"/doc/PEBLManual"+gPEBLVersion+".pdf $HOME/Documents/pebl-exp."+gPEBLVersion+"/")
          SystemCall("cp "+resources+"/doc/PEBLManual"+gPEBLVersion+".pdf $HOME/Documents/pebl-exp."+gPEBLVersion+"/","")
		
      }


		
	 } else {

       inst.text <- "Click window to exit."
	}
 }
 
       Draw()
	   Wait(500)
	   
 	   inst.text <- "Files copied. Next time you run PEBL, it will automatically run the launcher and show you the scripts in Documents/pebl-exp."+gPEBLVersion+"." + CR(1) +
	    "Click the window to exit."
	   Draw()
	   Draw()
   WaitForDownClick()
   
   
}


## This handles setting parameters for a selected script file.
##
define SetParameters(dirChain,scriptname,win,parname)
{

##  Print("setting praameters with:" + parname)
  path <- DirListToText(dirchain) +"params/"
  schema <- path+scriptname+".schema"
 
  ##this is what will be used for the default param file:
  if(parname=="default")
  {
    paramsfile <- path+scriptname
    parname <- scriptname
  }else{
    paramsfile <- path + parname
  }

   if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
   {
     parname <- parname + ".par"
     paramsfile <- paramsfile + ".par"
   }

  fail <- 0

  if((not FileExists(schema)))
   { 
      if(IsPEBLFile(scriptname))
         {
            PopupMessageBox("Schema file does not exist for script ["+scriptname+"]. Schema files are saved in the params\ subdirectory of the script's directory.  Most likely, the parameters of ["+scriptname+"] cannot be set using this interface.",win)
         }else{
            PopupMessageBox("To set parameters, select a .pbl file first. ["+scriptname+"] is not a PEBL script ending with .pbl",win)
         }


     fail <- 1
   }

 if(not fail)
  {
 
  ##Create background over current window.
  rect <- Rectangle(gVideoWidth/2,gVideoHeight/2,gVideoWidth,gVideoheight,MakeColor("grey80"),1)
  AddObject(rect,win)

  header <- EasyLabel("Editing parameters for "+path+scriptname,gVideoWidth/2,20,win,20)
  schemas <- ReadSchemaFile(schema)
  ts <- Transpose(schemas)
  defaults <- Transpose([First(ts),Second(ts)])

  parameters <- CreateParameters(defaults,paramsfile)  


  changed <- 0


  quit  <- MakeButton("Exit without saving",100,50,win,150)
  save <- MakeButton("Save file and exit",100,72,win,150)

  pnl <- EasyLabel("Parameters:",420,50,win,12)
  parnamebox <- EasyTextBox(parname,420-75,72-10,win,12,250,20)

  add <- MakeButton("New parameter set",260,72,win,150)
#  del <- MakeButton("Remove parameter",260,72,win,150)

  reset <- MakeButton("Reset to defaults",260,50,win,150)

  ##Now, make a grid showing values, etc., in the schema file
  ##We will set the rowheight adaptively..it should be set based on size 
  ##needed, but for now we will just stretch them all equally.

  ##out is [ui,vals,pluses,minuses,pmindex]
  out <- LayoutPGrid(schemas,parameters,win)

  ui <- First(out)
  vals <- Second(out)
  pluses <- Third(out)
  minuses <- Fourth(out)
  pmIndex <- Fifth(out)


  returns <- Sequence(1,Length(vals),1)


##add the click-on values at the end of the lists
  PushOnEnd(vals,save)
  PushOnEnd(vals,reset)
  PushOnEnd(vals,quit)
  PushOnEnd(vals,add)
  PushOnENd(vals,parnamebox)

  PushOnEnd(returns,"save")
  PushOnEnd(returns,"reset")
  PushOnEnd(returns,"quit")
  PushOnEnd(returns,"add")
  PushOnEnd(returns,"parnamebox")

##add the plus/minuses now 
 vals <- Merge(vals,pluses)
index <- 1
 loop(i,pmIndex)  ##add return index for pluses
 {
   PushOnEnd(returns,[i+1000,index])
   index <- index + 1
 }
  index <- 1
 vals <- Merge(vals,minuses)
 loop(i,pmIndex)  ##add return index for minuses
 {
   PushOnEnd(returns,[i+2000,index])
   index <- index + 1
 }



 Draw()
  ##Now, do a click-on loop to manage parameter updates. 
   cont <- 1
   while(cont)
   {
     resp <-   WaitForClickOnTarget(vals,returns)

    ##See if we need to edit something.
    if(resp == "quit")	
    {
      PushButton(quit,[0,0])
      cont <- 0
    }elseif(resp=="save")
    {

      PushButton(save,[0,0])

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
        ##Multi-parameter property:
       loop(j,value)
         {

          FilePrint(pfile,First(i)+"*,"+j)
         }
       }else{

         FilePrint(pfile,First(i)+","+value)

       }
      }

      cont <- 0

    } elseif(resp=="reset")
    {
     PushButton(reset,[0,0])
 
      pnames <- First(ts)
      defaults <- Second(ts)
      boxes <- SubList(vals,1,Length(schemas))
      loop(i,Transpose([pnames,defaults,boxes]))
      {
       SetProperty(parameters,First(i),Second(i))
       box <- Third(i)
       box.text <- Second(i)
      }
      Draw()

    }elseif(resp == "add")
    {
    ##this 'adds' a new parameter set, naming/saving it immediately.
      Pushbutton(add,[0,0])
      #this is really like 'save' but with a new name.

      ##figure out the new name:
      if(parnamebox.text == "default")
      {
        parname <- scriptname
        paramsfile <- path+scriptname

      }else {
	parname <- parnamebox.text
        paramsfile <- path+parname
      }
	if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
	{
  	 parname <- parname + ".par"
	 paramsfile <- paramsfile + ".par"
	}
      

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
       loop(j,value)
         {

          FilePrint(pfile,First(i)+","+j)
         }
       }else{

         FilePrint(pfile,First(i)+","+value)

       }
      }

    }elseif(resp == "parnamebox")
    {
        box <- parnamebox
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()

	parname <- GetInput(box,"<return>",1)
        paramsfile <- path+parnamebox.text
	if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
	{
  	 parname <- parname + ".par"
	 paramsfile <- paramsfile + ".par"
	}
	Draw()
  
    }elseif(IsList(resp))
    {
      ##plus or minus
      index <- First(resp)
      pmindex <- Second(resp)
      if(index > 2000)
      {    
         PushButton(Nth(minuses,pmindex),[0,0])
       }else{
         PushButton(Nth(pluses,pmindex),[0,0])
       }

    }  elseif(resp <= Length(schemas))
    {  ##Click and edit a parameter box:

        box <- Nth(vals,resp)
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()
	newval  <- GetInput(box,"<return>",1)
        SetProperty(parameters,First(Nth(schemas,resp)),newval)
     
    }
#   Draw()
   }
}

 return parname
}


##this does a layout on the parameter grid; suitable for 
##re-layout if the number of parameters change.
##We are given schemas, a list of triplets giving parametername,
##default value, description, and parameters, an object created by
##createparameters.
##
## multi-element properties are handled in the parameters
## as a list; within schemas,
## the names have a * at the end, and the values are (potentially)
## a comma-separated list.

define LayoutPGrid(schemas,parameters,win)
{
  pFontSize <- 11  ##this is the description font size; make a bit smaller for extra room.
  rowBase <- 80


  ##we need a better estimate of the length of the rows.
  rows <- []
  loop(i,GetPropertyList(parameters))
  {
     if(SubString(i,StringLength(i),1)=="*")
     {
       PushOnEnd(rows,SplitString(GetProperty(parameters,i),","))
     }else {
       PushOnEnd(rows,GetProperty(parameters,i))
     }
  }
  rows2 <- Flatten(rows)
  rowHeight <- Min([50,Floor(((gVideoHeight-5)-rowBase)/(Length(rows2)+2))])


  c1Base <- 100
  c1 <- 150
  c2 <- 100
  c3 <- 600


  head1 <- EasyLabel("Parameter name",c1Base+c1/2,rowBase+rowHeight/2,win,18)
  head2 <- EasyLabel("Value",c1Base+c1+c2/2,rowBase+rowHeight/2,win,18)
  head3 <- EasyLabel("Description",c1Base+c1+c2+c3/2,rowBase+rowHeight/2,win,18)

  ui <- []
  vals <- []
  pluses <- []
  minuses <- []
  pmIndex <- []

  prevparname <- ""
  counter <- 1
  row <- 1
  loop(i,schemas)
  {
     parname <- First(i)
     ##is this a multi-parameter set (specified with a *)
     singlepar <- 1

     if(SubString(parname,StringLength(parname),1)=="*")
     {
         parname <- SubString(parname,1,StringLength(parname)-1)
	 singlepar <- 0

        ##Schema is multi-parameter; the default values in the schema
	##are actually separated by commas.
	pvalues <- SplitString(Second(i),",")
	
       ##use CreateParameters to make sure these are converted to numbers

       fakeprop <- Repeat("fake",Length(pvalues))
       fakepar <- CreateParameters(Transpose([fakeprop,pvalues]),"")
       curvals <- fakepar.fake

     }else{
       curvals <- Second(i)
     }


     #Now, curval is either a list (for multi-parameters), or a value,
     ##based on the schema file.

     ##Use the pfile value in if it exists:
     if(PropertyExists(parameters,parname))
     {
       curvals <- GetProperty(parameters,parname)
     }

     if(not IsList(curvals))
     {
       curvals <- [curvals]
     }

     ##i is the schema for the current property, which we will still use for default parameters etc.
     ##curval is the current value from the parameter file or the schema (if no parameter file exists)


      loop(curval,curvals)
      {

      if(not singlepar)
      {
       ##Add +/- button for multiple parameters.
       tmpminus <- MakeButton("-",c1Base-40,rowbase+rowheight*(row+.5),win,18)
       tmpplus <- MakeButton("+",c1Base-20,rowbase+rowheight*(row+.5),win,18)
       PushOnEnd(ui,tmpminus)
       PushOnEnd(ui,tmpplus)
       PushOnEnd(pluses,tmpPlus)
       PushOnEnd(minuses,tmpMinus)
       PushOnEnd(pmIndex,row+1)

      }


      ##Now, add the UI elements for this parameter
      	

      r1 <- EasyTextbox(First(i)+"", c1Base,rowBase + rowHeight*row,win,12,c1-2,rowHeight-2)
      r2 <- EasyTextbox(curval+"", c1Base+c1,rowBase + rowHeight*row,win,12,c2-2,rowHeight-2)
      r3 <- EasyTextbox(Third(i)+" (default: ["+Second(i)+"])", c1Base+c1+c2,rowBase + rowHeight*row,win,pFontSize,c3-2,rowHeight-2)

      PushOnEnd(ui,r1)
      PushOnEnd(ui,r2)
      PushOnEnd(ui,r3)
      PushOnEnd(vals,r2)
      row <- row+ 1
    }

  }

  return [ui,vals,pluses,minuses,pmindex]
}

define ReadSchemaFile(filename)
{
   schemalist <- FileReadList(filename)
   list <- []
   loop(i,schemalist)
    {
       line <- SplitString(i,"|")
       PushOnEnd(list,line)
    }
  return list
}



##targetlist is a set of graphical objects,
##keylist is a set of keys whose corresponding 
##value should be returned when a graphical object is clicked upon.
## This modifies the built-in waitforclickontarget so that it will
## Return the button that is clicked, along with the target, 
## and the target object
define WaitForButtonClickOnTarget(targetlist,keylist)
{
  
  if(not IsList(targetlist))
  { 
    SignalFatalError("First argument of WaitForClickOnTarget(targetlist,keylist) must be a list of graphical objects")
  }

  if(not IsList(keylist))
  { 
    SignalFatalError("Second argument of WaitForClickOnTarget(targetlist,keylist) must be a list")
  }
  
  if(Length(targetlist) <> Length(keylist))
  {
    SignalFatalError("Arguments of WaitForClickOnTarget(targetlist,keylist) must be the same length")
  }

  obj <- ""
  ret <- ""
  testlist <- Reverse(Transpose([targetlist,keylist]))
   
   wait1 <- 1
   while(wait1)
     {
      wait2 <- 1
      while(wait2)
       {
         pos <- WaitForMouseButton()
         if((Nth(pos,4)=="<pressed>") or
            (Nth(pos,4)=="<wheel>"))
          {
            wait2 <- 0
            gClick <- pos
          }
       }

      newtargs <- []
	  
      loop(i,testlist)
          {

            if(Inside(pos,First(i)))
              {
	        obj <- First(i)
	        wait1 <- 0
                ret <- Nth(i,2)
                break
             }

          }
	  wait1 <- 0
     }
  ##Print([ret,pos,obj])
  return [ret,pos,obj]
}

##this returns a list of actual parameter files
## in the params\ directory.
##if the params\ directory does not exist, it returns an 
##empty list.  If it does exist but no .par files are there,
##it returns '["default"]'.  Otherwise, it appends the .par
## list to ["default"]


define GetParFiles()
{  
 paramsdir <- DirListToText(gDirChain)+"params"  
 if(FileExists(paramsdir))
  {
    parfiles <- Merge(["default"],
              Second(FilterDir(GetDirectoryListing(paramsdir),
                    gDirChain,"*.par")))
  } else {
    parfiles <- []
  }

 return parfiles
}


define GetConfigFiles()
{  

  
  dir <- DirListToText(gDirChain)  
  if(FileExists(dir+"/configfiles/"))
  {
  conffiles <- Second(FilterDir(GetDirectoryListing("./configfiles/"),
                              gDirChain,"*.config"))
  }else{
   conffiles <- []
  }
 return conffiles
}


define ListEqual(l1,l2)
{
  if(Length(l1)==Length(l2))
  {
   same <- 1


   loop(i,Transpose([l1,l2]))
    {
     if(not (First(i) == Nth(i,2)))
      {
        same <- 0
      }

    }
   } else {
     same <- 0
   } 
  return same
}



define UpdateScreenResPulldown(pd)
{



	  ##get a list of available screen modes:
 	  selected <- -1
	  currentxy <- gScreenRes
      screenmodes <- GetVideoModes()
	  #MessageBox(ConcatenateList(screenmodes,"|"),gWin)
	  screenmodes <- SortBy(screenmodes,First(Transpose(screenmodes)))

	  ##add 'current' and 'custom':
	  screenmodes <- Append(screenmodes,gCurrent)
	  screenmodes <- Append(screenmodes,gCustomText+gCustomScreenRes)

         ##if we have set a custom res, add another one that will let us edit 
         if(not gCustomScreenRes=="")
	  {
  	    screenmodes <- Append(screenmodes,gCustomText)
	  }



	  ##create a list of text-based screen modes to choose from:
          modes <- []
          index <- 1
	  loop(i, screenmodes)
	  {

	    ##most of the screenmodes will be list-pairs; but some will
	    ##be the labels we just added
	    if(IsList(i))
	    {
     	      tmp <- First(i)+"x"+Second(i)
	    }else{
	      tmp <- i
            }


	    if(tmp==currentxy)
	    { 
               tmp <- tmp + "*"
               selected <- index

       	    }

	     modes <- Append(modes, tmp)
	     index <- index + 1
	  }

	  ##Add the custom option to the end of each:

	  ##screenmodes is the nested list of resolutions
	  ##modes is the text that is inside pd
	  ##set the selected to 'default' if no match.
	  if(selected==-1)
	  {
	    selected <- Length(pd.list)-1
	  }
         
	  pd.selected <- selected
	  UpdatePulldown(pd,modes)
	  pd.selected <- selected
	  return screenmodes
}


define OpenManual(obj,click,extra:0)
{
     #SystemCall(gManualLoc,"")	  
     #Print(gManualLoc)
     #PopUpMessageBox(gManualLoc,obj.win)

    LaunchFile(gQuote+gManualLoc+gQuote)
}


define ChangeLaunchersize(obj,click,extra:0)
{

   
    if(gParams.ScreenSize=="small")
      {
           gParams.ScreenSize <- "large"
      } else {
           gParams.screenSize <- "small"
      }

   SaveParamFile(gparams,"params/launcher.pbl.par")
 if(1) {
   PopupMessageBox(gRelaunchMessage,obj.win)

   }else{

   ##this stuff is too fussy to work right now.
   if(gScreenSize =="large")
   {
     gVideoWidth <- 1000
     gVideoheight <- 700
   }elseif(gScreenSize=="small")
   {
     gVideoWidth <- 1000
     gVideoheight <- 600
   }
   ResizeWindow(obj.win,gVideoWidth,gVideoheight)


   box <- gMessageBox.box
    ##we need to update the scrollbox:
   scrollH <- gVideoheight - gMessageBox.y-10
   lineheight <- gmessagebox.lineheight  
   obj.maxitems <- Floor(scrollH/lineheight)-2 
   box.height <- lineheight*obj.maxitems

   outline <- gmessageBox.outline
   outline.height <- scrollH
   outline.y <- gVideoWidth-scrollH/2-10
   outline
   gMessageBox.y <- scrollH
  }
   
}


define EnableDisableScreenshots(obj,click,extra:0)
{
   gParams.useScreenshots <- 1-gParams.useScreenshots

   SaveParamFile(gparams,"params/launcher.pbl.par")

  if(gParams.useScreenshots)
  {
    PopUpMessageBox(gScreenShotTextOn,obj.win)

   }else{
     PopUpMessageBox(gScreenShotTextOff,obj.win)
   }
}

define Aboutmessage(obj,click,extra:0)
{
   MessageBox(gAboutText,obj.win)
}


define ExitPEBL(obj,click, extra:0)
{
     Saveconfig(gconfigname)
     gCont <- 0
}

define GoToWeb(obj,click,extra:0)
{
         #SystemCall("http://pebl.sourceforge.net","")	  
	 Launchfile("http://pebl.sourceforge.net")	  
}

define SetPassword(obj,click,extra:0)
{
         PopUpScreen(obj.win)

}


define VisitWiki(obj,click,extra:0)
{
       if(Length(gDirChain)>1)
       {
         root <- Nth(gDirChain,Length(gDirChain))+"/"
       }  else {
	     root <- ""
       }
       wikipagename <- root+Nth(gFlatFileList,gselected)
	   if(wikipagename=="." or wikipagename=="..")
        {
         wikipagename <- "Main_Page"
        }
	   Launchfile("http://pebl.sourceforge.net/wiki/index.php?title="+wikipagename)

}

define Review(obj,click,extra:0)
{
    PopUpMessageBox("A web browser should open to the PEBL Review page at http://sourceforge.net/projects/pebl/reviews/",obj.win)
   Launchfile("http://sourceforge.net/projects/pebl/reviews/")

}

define Donate(obj,click,extra:0)
{
      PopUpMessageBox("A web browser should open to the PEBL donation page at   http://www.superiorideas.org/projects/open-source-psychology-software",obj.win)	
       Launchfile("http://www.superiorideas.org/projects/open-source-psychology-software")
}


 
define ReloadStdOutErr(obj,click,extra:0)
{

  ReadStdOutStdErr()
  if(gMessageBox.stdout)
  {
    UpdateStdOut(gMessageBox,[0,0])
  }  else{
    UpdateStdErr(gMessageBox,[0,0])
  }
}


##this reads the stdout/stderr files.
define ReadStdOutStdErr()
{	     
	  	     
       file <- DirListToText(gDirChain)+"stdout.txt"


       if(FileExists(file))
          {

            gStdoutlist <- "stdout.txt"+CR(1)+FileReadText(file)
          }
  

         file <- DirListToText(gDirChain)+"stderr.txt"

          if(FileExists(file))
            {
  	       gStdErrlist <- "stderr.txt:"+CR(1)+FileReadText(file)
            }
	
}

define UpdateStdErr (obj,click,extra:0)
{

    SetScrollingText(gMessageBox,gStdErrList)
    Draw(gMessageBox)
      gSTdOutHighlight.x <- gMenuStdErr.x+gMenuStdErr.width/2
      gMessageBox.stderr <- 1
      gMessageBox.stdout <- 0
}

define UpdateStdOut (obj,click,extra:0)
{

     SetScrollingText(gMessageBox,gStdOutList)
      ##This can take several seconds..:
      Draw(gMessageBox)
      gSTdOutHighlight.x <- gMenuStdOut.x+gMenuStdOut.width/2
      gMessageBox.stderr <- 0
      gMessageBox.stdout <- 1

}



define Dummy(obj,click,extra:0)
{
   PopupMessageBox("Dummy",obj.win)
}

define Tutorial(obj,click,extra:0)
{
   Launchfile("http://pebl.sourceforge.net/wiki/index.php/CogSci2011_Tutorial")
}
## This updates the things that change whenever the directory changes:
## the path, the screenshot, and the description.
##
define UpdateScreen(win)
 {

   if(gSelected>Length(gFlatFileList))
   {
      gSelected <- Length(gFlatFileList)
   }
   x <- gPath.x-gPath.width/2
   y <- gPath.y-gPath.height/2
   gPath.text <- DirListToText(gDirChain)


    MoveCorner(gPath,x,y)


   if( gParams.UseScreenshots)
   {

     ##figure out the name of the screenshot, if it exists:

     
     screenname <-DirListToText(gDirChain)+ 
                    Nth(gFlatFileList,gselected)+".png"

     ##update the screenshot, etc.
     descname <- DirListToText(gDirChain)+Nth(gflatfilelist,gselected)+".about.txt"



     if(FileExists(screenname))
      {


	     RemoveObject(gScreenshot,win)
	     gScreenshot <- MakeImage(screenname)


	     AddObject(gScreenshot,win)

 	     ##scale to 400x300
	     scalew <- 400/gScreenshot.width  
	     scaleh <- 300/gScreenshot.height
	     scale <- Min([scalew,scaleh])


	     gScreenshot.zoomX <- scale
	     gScreenshot.zoomY <- scale

	     Move(gScreenshot,gScreenshotbase.x,gScreenshotbase.y)

      } else {
	  


          ##try to find any .png file, provided it is a  subdirectory
           if(IsDirectory( DirListToText(gDirChain)+
                            Nth(gFlatFileList,gselected)))
	    {


	     list <- GetDirectoryListing( DirListToText(gDirChain)+
                                        Nth(gFlatFileList,gselected))


  	     pbls <- Second(FilterDir(list,gDirChain,"*.pbl"))


	     pngs <- Second(FilterDir(list,gDirChain,"*.png"))


         abouts <- Second(FilterDir(list,gDirChain,"*.about.txt"))



	     loop(i,pbls)
              {

	       if(IsMember(i+".png",pngs) and IsMember(i+".about.txt",abouts))
	         {


                    ##update the screenshot, etc.
                   descname <- DirListToText(gDirChain)+
                        Nth(gFlatFileList,gselected)+"/"+i+  ".about.txt"

                   screenname <-DirListToText(gDirChain)+
                        Nth(gFlatFileList,gselected)+"/"+i+".png"
  		   break
                  }

	       }




            if(FileExists(screenname))
              {


                  RemoveObject(gScreenshot,win)
    	         #Print("UPDATESCREEN    13.2:" + GetTime()) 
    	          gScreenshot <- MakeImage(screenname)  ##This takse 10+ ms
     	        # Print("UPDATESCREEN    13.3:" + GetTime())
                  AddObject(gScreenshot,win)

   	          ##scale to 400x300
	          scalew <- 400/gScreenshot.width  
	          scaleh <- 300/gScreenshot.height
 	          scale <- Min([scalew,scaleh])

	          gScreenshot.zoomX <- scale
	          gScreenshot.zoomY <- scale
	          Move(gscreenshot,gscreenshotbase.x,gscreenshotbase.y)

              } else {


  	      RemoveObject(gScreenshot,win)
	      gScreenshot <- gScreenshotdummy
	      AddObject(gScreenshot,win)

              }
           }else{


  	      RemoveObject(gScreenshot,win)
	      gScreenshot <- gScreenshotdummy
	      AddObject(gScreenshot,win)


      }
    }


     if(FileExists(descname))
      {


         text <- FileReadText(descname)
#Print("UPDATESCREEN    21:" + GetTime())

         SetScrollingText(gDescription,text,1)
#         Print("UPDATESCREEN    22:" + GetTime())

         Draw(gDescription)
#	 Print("UPDATESCREEN    23:" + GetTime())

      } else {


         SetScrollingText(gDescription,gNoDesc,1)
         Draw(gDescription)
      }
   }

}




define PopUpScreen(win)
{

##here is the 'nag' screen.
 text <- "Thank you for using PEBL: The Psychology Experiment Building Language. 

We appreciate your support! This software is licensed with the GPLv2, and is provided free of charge.  You are free to modify, share, and redistribute PEBL, and unlike most commercial tests, you can observe how it works and what it calculates. Please cite PEBL if you use it:

Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods, 222, 250–259.

To skip this screen when you start-up, enter the password.  You can get a password by donating to the project, or by contributing in other ways to the project (translations, new tests, normative data, bug reports, writing wiki documentation, and so on)"


  boxwidth <- 651
  boxheight <- 301
  if(not IsWindow(win))
  { 
    SignalFatalError("PopupScreen(win) needs a window to be specified, not [" + win + "]")
  }



   	   
    xpos <- gVideoWidth/2
    ypos <- gVideoheight/2
  
   bgcol <- win.BGCOLOR

   popup  <- MakeCanvas(boxwidth,boxheight,MakeColor("grey60"))
   Move(popup,xpos,ypos)
   AddObject(popup,win)
   
   
   bg <- Rectangle(boxwidth/2,boxheight/2,boxwidth-2,boxheight-2,bgcol,1)
   AddObject(bg,popup)
   font <- MakeFont(gPEBLBaseFont,0,13,MakeColor("black"),bgcol,0)
   box <- MakeTextBox(text,font,boxwidth-20,boxheight-50)
   Move(box, 10,20)
   AddObject(box,popup)

   Draw(popup)
#   Hide(bg)
#   Hide(box)



   entrybox <-  EasyTextBox("",popup.width/2+15,
                               popup.height-70, 
                               popup,13,180,20)


   ok    <- MakeButton("Enter/Confirm password:",entrybox.x-105,entrybox.y+10,popup,200)

   try  <- MakeButton("Use without password",popup.width/2-200,entrybox.y+45,popup,170)

   donate <- MakeButton("Contribute and get password",popup.width/2-10,entrybox.y+45,popup,200)
   contribute <- MakeButton("How else can I help?",popup.width/2+200,entrybox.y+45,popup,200) 

   thermo <- Rectangle(entrybox.x-entrybox.width/2,entrybox.y-entrybox.height/2,
   0,entrybox.height,MakeColor("darkblue"),1)
   AddObject(thermo,popup)

   Draw()
   totaltime <- 2000
   endtime <- GetTime()+totaltime
   timeleft <- endtime - GetTime()
   while( timeleft>0)
   {
      thermo.width <- entrybox.width* timeleft/totaltime
      MoveCorner(thermo,entrybox.x,entrybox.y)
      Draw()
      Wait(5)
      timeleft <- endtime - GetTime()
   }
   Hide(thermo)


   Draw()
 
  cont <- 2
  while(cont)
  {
  
    resp <- WaitForButtonClickOnTarget([entrybox,ok,try,donate,contribute],[1,2,3,4,5])
   id <- First(resp)
   click <- Second(resp)
   obj <- Third(resp)



   if(id==1)    ##select and enter password
    {

	   relx <- First(click) - (entrybox.x )
	   rely <- Second(click) - (entrybox.y )

	   entrybox.cursorpos <- (GetTextBoxCursorFromClick(entrybox,relx,
                                                                     rely))
	   Draw()
        pw  <- GetInput(entrybox,"<return>",1)
        cont <- 1


    }elseif(id==2)
    {
      PushButton(obj,click)
     ##check password here.
      pw <- entrybox.text
      passwordhash <- MD5Sum(pw)

      gParams.pwhash <- passwordhash
      if(gParams.pwhash=="2627692e567165c7a474f3ea97c07912")
      {
        cont <- 0
		gPasswordEntered <- 1
      }else{
       PopUpMessageBox("Sorry, this password in incorrect.  Enter correct password or use without password.",win)
       entrybox.text <- ""
       cont <- 1
	   gPasswordEntered <- 0

     }
    }elseif(id==3)
    {
     PushButton(obj,click)
     ##don't check password here.
     cont <- 0
     PopUpMessageBox("Please help support PEBL development or if you are able",win)
   
   }elseif(id==4){
     PushButton(obj,click)
     ##go to donation page

     Launchfile("http://www.superiorideas.org/projects/open-source-psychology-software")
    PopUpMessageBox("A web browser should open to the PEBL donation page at      http://www.superiorideas.org/projects/open-source-psychology-software",win)

   }elseif(id==5){
     PushButton(obj,click)
    PopUpMessageBox("A web browser should open to the PEBL contributions page at http://pebl.sourceforge.net/wiki/index.php/How_can_I_contribute",win)
     Launchfile("http://pebl.sourceforge.net/wiki/index.php/How_can_I_contribute")
  }


   Draw()

  }
   return entrybox.text
}


define SaveParamFile(params,file)
{
  plist <-[]
  loop(i,GetPropertyList(params))
   {
     PushOnEnd(plist, [i,GetProperty(params,i)])
   }
   FileSaveTable(plist,file)
}



##This shadows the one in UI.pbl
define EditScrollboxValue(win,click,default,selected)
{

     if(selected <= Length(gExpChain))
	 {
     line <-Nth(gExpChain,selected)

     filename <-  "Filename:     " +DirListToText(Nth(line,1)) +    Nth(line,3) + CR(1)+
                  "Parameters: " +Nth(line,4)

     newval <-  PopUpEntryBox("Enter Label for "+CR(1)+filename,win,click,default,400,150)

     ##substitute characters that might break csv file.
     newval <-ReplaceChar(newval, [CR(1), ","], " ")
     SetElement(line,2,newval)
      } else {
       newval <- ""
	  }
     return newval
}


## This makes a chain entry for gDirChain.
define MakeChainEntry(dirchain,label,filename,parameterset)
{

  return [dirchain,label,filename,parameterset]
}
