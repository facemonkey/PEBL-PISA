###########################################################
##  Berg's Card Sorting Task, Version 0.6
##  (better known as the Wisconsin Card Sorting Test (tm)).
##  http://pebl.sf.net
##  Part of  The PEBL Psychological Testing Battery
##  2006-03 Released into Public Domain
##  by Shane T. Mueller, Ph.D. (smueller at obereed dot net)
##
##  as found in:
##  E. A. Berg. (1948). A simple objective technique for measuring
##     flexibility in thinking. J. Gen. Psychol. 39: 15-22.
## 
## 
## Polish translation contributed by Artur Pilacinski
## Korean translation contributed by Hyunsoo ra ma 
## Chinese translation contributed by Yu-Hsiang Wu 
## Portuguese translation contributed by Arthur Kummer
## Spanish translation contributed by Nuria Carriedo
## French translation contributed by Elise Branchereau
## Lithuanian translation contributed by Sigita Cinciute
## Slovakian (si) translation contributed by Maja Drascek

###########################################################
##  Raw data file outputs:
##  subnum, trialnum, category count, color, shape, number, response, accuracy
##  perseveration count, absolute time, response time.
define Start(lPar)
{

  ##First, let's read in/set default parameters.

  parpairs <- [["repeats",2],
               ["runlength",10],
               ["useCanonical",1],
               ["useReduced",0],
               ["rulefeedback",0],
               ["usemouse",1]]

  gParams <- CreateParameters(parpairs,gParamFile)

  ## repeats is the number of times you go through the deck (deck size 
  ## depends on whether useReduced is 0 or 1).
#  repeats <- 2

  ## This is how long of a run is required before switching categories.
  ## Note: Versions 0.1 -0.2 of BCST used runlength 5 by default.
  ## This is now changed to be 10, which according to the Neuropsych
  ## Assessment Handbook is the typical version.

#  runlength <- 10

  ## useCanonical determines whether the 'stimulus' cards are the same
  ## as in Berg, or whether they are chosen randomly.
#  useCanonical <- 1

  ## Reduced uses a 24-card deck, removing cards sharing  2+
  ## attributes with stimulus cards
  ## See Nelson HE: A modified card sorting test sensitive to 
  ##        frontal lobe defects. Cortex 1976;12:313-324.
  ## Note: modified card sort also may use shorter runlength.
#  useReduced <- 0

  ###########################################
  ## The variable gRuleFeedback gives a cue when the rule changes.
  ## set from 0 to 1 to turn this feedback ON.
  ## The exact feedback may need to be translated into your own
  ## language.
#  gRuleFeedback <- 0


#  gUseMouse <- 1   #0 for keyboard 1-4, 1 for mouse entry.

  GetStrings(gLanguage)



  ## Initialize global objects for use later. Defined at end of file
  Initialize()

  gFileheader <- "subnum,trial,run,rule,lastrule,color,shape,number,resp,corr,last_corr,corr_col,corr_shape,corr_num,persev,persev_err,abstime,rt"
  gFileOut <- GetNewDataFile(gSubNum,gWin,"bcst","csv",gFileheader)


  report <-GetNewDataFile(gSubNum,gWin,"bcst-report","txt","")

  pooledname <-"data/cardsort-pooled.csv"
  if(FileExists(pooledname))
  {
   header <- ""
  }else{
   header <- "subNum,TimeStamp,timeinsec,runlength,numcats,"+
      "numTrials,totCorr,err,totPers,totPersErr,nonp,totUnique,"+
      "firstcat,failuretomaintain,learningtolearn,"+
      "conceptual,totPersPAR,totPersErrPar"
  }

  pooledFile <- FileOpenAppend(pooledname)
  if(not header=="")
   {
     FilePrint(pooledFile,header)
   }
  gSleepEasy <- 1
  persevs <- []
  totCorr <- 0
  totPers <- 0
  totPersErr <- 0
  totUnique <- 0   ##Counts number of 'unique' errors; errors that are not correct by another rule.

  persrun <- []  ##computes length of 'perseverative runs'
  persrunflag <- 1

  if(gParams.UseMouse==0)
   {
     ShowCursor(0)  #hide the cursor
   }

   gColors <-  ["Red", "Green","Yellow","Blue"]
   gShapes <-  ["Triangle","Star","Cross","Circle"]
   gNumbers <- ["1","2","3","4"]

   ##Does this really work?
   rules <- ShuffleWithoutAdjacents([[1,1,1],[2,2,2],[3,3,3]])

  ##Mix up the order if we aren't using canonical stimulus cards.
  if(not gParams.useCanonical)
   {
     gColors <- Shuffle(gColors)
     gShapes <- Shuffle(gShapes)
   }
  
  csn <- DesignFullCounterbalance(DesignFullCounterbalance(gColors,gShapes),gNumbers)


 if(gParams.useReduced)
   {
    #compute the reduced deck, dependent on the current pile stacks

    ccsn <- []
     #Go through each possible card

     loop(i, csn)
     {
       col <- First(First(i))
       shape <- Nth(First(i),2)
       num   <- Nth(i,2)

       #compare the card to each pile-card; counting matching features       

       maxmatch <- 0
       cards <- Transpose([gColors,gShapes,gNumbers])
      loop(card,cards) 
        {
          matches <- (col==First(card)) + (shape ==Nth(card,2)) + (num==Nth(card,3))
          maxmatch <- Max([matches,maxmatch])

        }

       ##only add to the used deck if it matches on fewer than two features.
       if(maxmatch <2)
        {
            ccsn <- Append(ccsn,[[col,shape],num])
        }
     }

    csn <- ccsn
   }

  decksize <- Length(csn)

  stimcat <- FoldList(Flatten(Repeat(csn,gParams.repeats)),3)

  images<-[]
 
  loop(i,stimcat)
  {
    filename <- "png/" + ListToString(i) + ".png"
    x <- MakeImage(filename)
    images <- Append(images,x)

  }

  ginstructions.text <- gInst1
  Show(gInstructions)
  Draw()
  WaitForIt()

  stim <-	Shuffle(Transpose(Append( Transpose(stimcat),images)))


   ## load canonical comparison cards.  This is perhaps supposed to
   ## be randomized.

   comps <- Transpose([gColors,gShapes,gNumbers])
   comp1 <- MakeImage("png/"+ListToString(First(comps))+".png")
   comp2 <- MakeImage("png/"+ListToString(Nth(comps,2))+".png")
   comp3 <- MakeImage("png/"+ListToString(Nth(comps,3))+".png")
   comp4 <- MakeImage("png/"+ListToString(Nth(comps,4))+".png")


   AddObject(comp1,gWin)
   AddObject(comp2,gWin)
   AddObject(comp3,gWin)
   AddObject(comp4,gWin)

   ##The complicated positioning here is just a dumb way
   ##to center left-to-right
   Move(comp1, gVideoWidth/2 - 400 +28 + 125/2, 105)
   Move(comp2, gVideoWidth/2 - 400+ 28*2 + 125 + 125/2,105)
   Move(comp3, gVideoWidth/2 - 400+ 28*3 + 125*2 + 125/2,105)
   Move(comp4,  gVideoWidth/2 - 400+28*4 + 125*3 + 125/2,105)

   if(gParams.UseMouse == 0)
   {
     gHeader.text <- "1           2            3            4"
   }
   Move(gHeader,gVideoWidth/2-80,220)
   Show(gHeader)
   ## Give instructions; wait for them to hit a key, 
   SetText(gInstructions,gInst2)
   Show(gInstructions)
   Draw()  
   WaitForIt()


   gInstructions.text <- gInst3
   Draw()
   WaitForIt()

   Hide(gInstructions)
   Show(gPrompt)
   Draw()
                 


  ####################################################
  ## Begin presenting and collecting data
  ####################################################
 

####################################################
##  Start the experimental trials.
## 

  rule <- First(rules)
  rules <- Rotate(rules,1)
  lastrule <- -1
   
  failuretomaintain <- 0  ##failure to maintain set

  trialsoncat        <- 0  ##how long have you been working on this trial?
  trialspercat      <- [] ##Keep a list of the trials taken per category.
                          ##This is used to measure learning-to-learn
  erroroncat        <- 0  ##how many errors on this category
  errorspercat      <- [] ##Keep a list of the errors made on the category
                          ##This is used to measure learning-to-learn
 
  conceptual        <- 0  ##Record conceptual responses: 3-runs or greater
  firstCat <- 0
  run <- 0
  persev <- 0
  trialnum <- 1
  numCats <- 0
  numCatsExp <- 1
  dataTable <- []

  ##These keep track of some statistics ala the PAR-task.


  ##Loop through each stimulus card
   loop(s,stim)
   {

      trialsoncat <- trialsoncat+1


      #Display the card
      card <- Nth(s,4)
      AddObject(card,gWin)
      Move(card,gVideoWidth/2+100,380)
      Draw()
      time0 <- GetTime()

  ## Get the response
  simulate <-0

  if(simulate) 
   {
    ##simulate responses to check scoring.    
    resp <- Sample([1,2,3,4])
    if(Random()<.8)
    {

     while(Second(ScoreTrial(s,resp,rule,lastrule))==0)
      {
        resp <- Sample([1,2,3,4])
      }
    }
   } else {
      if(gParams.UseMouse)
      {  
         resp <- WaitForClickOnTarget([comp1,comp2,comp3,comp4],["1","2","3","4"])
      }else{
         resp <- WaitForListKeyPress(["1","2","3","4"])
      }
  }

      time1 <- GetTime()
      rt <- time1 - time0

      ## Score the trial returns a pair.  [cur-rule, last-rule]
      ##
      corrBoth <- ScoreTrial(s,resp,rule,lastrule)

      
      corrLast <- First(corrBoth)
      corr <- Nth(corrBoth,2)


     ##Also compute whether the choice was correct for each given rule
      corrCol   <- Nth(gColors,ToInteger(resp)) == Nth(s,1)
      corrShape <- Nth(gShapes,ToInteger(resp)) == Nth(s,2)
      corrNum   <- Nth(gNumbers,ToInteger(resp))== Nth(s,3)
      
      ##animate the card location.

      #Get end location
      x <- gVideoWidth/2-400+125/2 + 28*ToInteger(resp) + 125*(ToInteger(resp)-1)
      y <- 105
     ##compute distance to travel to scale frames to distance.
      dist <- Sqrt((y-card.y)^2 + (x-card.x)^2)
      #Increase stepsize to animate faster
      stepsize <- 100
      frames <- Ceiling(dist/stepsize)+1  

      ydiff <- (y - card.y)/(frames)
      xdiff <- (x - card.x)/(frames)
      steps <- Sequence(frames,0,-1)
      #move toward end location
      loop(i,steps)
      {
        card.x <- x - xdiff*i
        card.y <- y - ydiff*i
        Draw()
	Wait(5)##Without waiting, this ca go too fast on OSX.
      }

      RemoveObject(card,gWin)

      #If it is correct, update run counters
      if(corr == 1)
      {
        run <- run + 1
        totCorr <- totCorr + 1
        feedback <- gCorrect
      } else {
        ##It is incorrect.
        feedback <- gIncorrect    
        ##Increment failuretomaintain if run>=5
        if(run>=5)
         {
		    failuretomaintain<- failuretomaintain+1
         }

         erroroncat <- erroroncat + 1  ##  increment category-specific
                                       ##  error 

        ##Increment conceptual responses here, when the run ends on an error
        if(run>=3)  
         {
           conceptual <- conceptual + run
         }
        run <- 0
     
      }


 
     ##If it was correct according to the last rule, increment counters.
      if(corrLast == 1) {

           totPers <- totPers + 1
           persev <- persev + 1
           trialpersev <- 1	
           trialPersevErr <- 0




          ##If it was also an error, this is a perseverative error.
          if(corr==0)
              {
                  totPersErr <- totPersErr +1 
                  trialPersevErr <- 1
              }

          } else {

         #####################
         ##  This trial was not a perseveration (it could be either correct or incorrect)
    
         ##Make sure these are defined
           trialPersev   <- 0
           trialPersevErr <- 0
           ##If the runflag is still 1, that means this is the first non-perseverative response
           ## in the category.  Unset the flag and record the length of the run.
           if(persrunflag)
                {
                   persrunflag <- 0
                   ##Add the current perseverative run count; 
                   ## only do so after the first category
				   if(numCats >0)
                   {
					persRun <- Append(persRun, persev)
                   }
                }

           }


      ##This determines if the response is a 'unique' response; i.e.,
	  ## not correct according to any rule

      
      rulesum <- (corrCol + corrShape + corrNum)

        ##It was incorrect, and not correct according to the previous rule, and not 
        ##a match to another property of the card, increment the unique counter
         if(corr==0 and corrLast == 0  and rulesum == 0)
         {
		   totUnique <- totUnique + 1
         }

	 line <-[gSubNum , trialnum , numCatsExp, rule,lastrule ]


	  FilePrint_(gFileOut, gSubNum + "," + trialnum + "," + numCatsExp +  "," + rule + "," + lastrule + ",")
      index <- 1
      ##Print out the trial data.
      loop(i,s)
      {
        if(index !=4)
        {
         FilePrint_(gFileOut,i+",")
	 PushOnEnd(line,i)
        }
       index <- index + 1
      }

	  FilePrint_(gFileOut, resp + "," + corr + "," + corrLast + "," +  corrCol + "," + corrShape + "," + corrNum + ",")

      FilePrint( gFileOut, trialpersev + "," + trialperseverr + "," +  time0 + "," + rt )

     line <- Merge(line, [resp,corr,corrLast,corrCol,corrShape,corrNum,
                       trialPersev,trialPersevErr,time0,rt])
      PushOnEnd(datatable,line)

      Show(feedback)
      Draw()
      if(not simulate)
      {
        Wait(500)
      }
      Hide(feedback)
#      Hide(gHeader)
#      Hide(gPrompt)
      Draw()

      ##if you have a run of runlength correct, change rules.
      if(run >= gParams.runlength)
      {
        lastrule <- rule
        rule <- First(rules)
        rules <- Rotate(rules,1)

        #Update conceptual responses when a category is complete
        conceptual <- conceptual + run

### This gives rule-change feedback: 
##  It is not yet properly translated.
  if(gParams.RuleFeedback)
  {
    tmp <- gPrompt.text
    gPrompt.text <- "Now the rule has changed"
    Draw()
    Wait(500)
    gPrompt.text <- tmp
    Draw()
  }


        run <- 0
        numCats <- numCats + 1
        numCatsExp <- numCatsExp + 1
        
        lastswitch <- trialnum
        ##Keep track of the number of perseverations in this category.
        persevs <- Append(persevs, persev)
        persev <- 0
      
        persrunflag <- 1       ##Reset the perseverative run flag.
        ##Record the number of trials needed to attain first category.  
        if(numCats == 1)
        {
          firstcat <- trialnum
        }
		##update the trialsoncat/trialspercat counters
		trialspercat <-Append(trialspercat,trialsoncat)
        errorspercat <-Append(errorspercat, erroroncat)
        erroroncat <- 0
		trialsoncat <- 0

      }

      trialnum <- trialnum + 1
      if(numCats >= 9 )
      {
        numCatsExp <- 9
        break
      }
    }

    #The last card may have ended before the end.
    #If it were complete, run would have been reset to 0.  
    #Add partial run to conceptual responses
    if(run>=3)
     {
        conceptual <- conceptual + run
     }


	##Do the final output and computations.

  ##compute hand things up-front
   num <- trialnum - 1
   err <- num - totCorr
   nonp <-  (err-totPersErr)

   #################################################
   ##compute learning-to-learn.
    if(Length(trialspercat)>2)
   {
    if((Length(trialspercat)>3) or 
        (Length(trialspercat)==3 and  Third(trialspercat)>=10))
 		{
        #Compute the number of extra trials, and the 

        diffs  <- []
        lastpc <- "XXX"
          
        tt <- 1  ##trial counter
        loop(i,Transpose([trialspercat,errorspercat]))
         {
           ##Only use this if there were 10 or more trials
           if(i>=10)
              {
                  pc <- Second(i)/First(i)*100
              }

           if(tt > 1)
            {
                diffs <- Append(diffs,pc-lastpc)
                
            }
           tt <- tt + 1
           lastpc <- pc
         }
         learningtolearn <- Mean(diffS)

      } else {
       ##Invalid to compute learning-to-learn
        learningtolearn <- "Not enough data"
      }} else{
       ##Invalid to compute learning-to-learn
        learningtolearn <- "Not enough data"
      }


   FileClose(gFileOut)





   FilePrint(report,"---------------------------------------------------")
   FilePrint(report," Report for PEBL's _Berg's Card Sorting Task_,")
   FilePrint(report," a free version of the Wisconsin Card Sorting Task (tm)*")
   FilePrint(report," (c) 2008-2010 Shane T. Mueller")
   
   FilePrint(report," Version 0.8")
   FilePrint(report," "+GetPEBLVersion())
   FilePrint(report," "+TimeStamp())
   FilePrint(report," Participant Code: " + gSubNum)
   FilePrint(report," http://pebl.sf.net")
   FilePrint(report,"---------------------------------------------------")
   FilePrint(report,"Parameters:")
   FilePrint(report,"Run length to move to next category: "+gParams.runlength)
   FilePrint(report,"Number of times through deck: "+gParams.repeats)
   FilePrint(report,"Deck Size: "+ decksize)
  
   FilePrint_(report,"Order of Cards: Rule 1  (color): ")
      loop(i,gColors)
      {
         FilePrint_(report,i+" ")
      }
   FilePrint(report,"")

   FilePrint_(report,"                Rule 2  (shape):  " )
      loop(i,gShapes)
      {
         FilePrint_(report,i+" ")
      }
   FilePrint(report,"")

   FilePrint_(report,"                Rule 3 (number):  ")
      loop(i,gNumbers)
      {
         FilePrint_(report,i+" ")
      }
   FilePrint(report,"")


   FilePrint(report,"---------------------------------------------------")
   FilePrint(report,"Statistic                    Value")
   FilePrint(report,"---------------------------------------------------")
   FilePrint(report,"1. Categories Completed/Experienced: "+ numCats + " / " +numCatsExp)
   FilePrint(report,"2. Number of Trials:              " + num)

   FilePrint(report,"                                     ---------------------------")
   FilePrint(report,"                                     Total Percent Mean/Cat")
   FilePrint(report,"3. Correct Responses:             " + totCorr + Tab(1) + Roundoff(totCorr/num,4)*100 + Tab(1) + Roundoff(totCorr/numcatsExp,3))
   FilePrint(report,"4. Total Errors:                  " + err + Tab(1) + Roundoff(err/num,4)*100 + Tab(1) + Roundoff(err/numCatsExp,3))
   FilePrint(report,"5. Perseverative Responses (PEBL) " + totPers + Tab(1) + Roundoff(totPers/num,4)*100 + Tab(1) + Roundoff(totPers/(numCatsExp-1),3))
   FilePrint(report,"6. Perseverative Errors    (PEBL) " + totPersErr + Tab(1) + Roundoff(totPersErr/num,4)*100 + Tab(1) + Roundoff(totPersErr/(numCatsExp-1),3))





   FilePrint(report,"7. Non-Perseverative Errors        " + nonp + Tab(1) + Roundoff(nonp/num,4)*100 + Tab(1) + Roundoff(nonp/(numCatsExp),3))
   FilePrint(report,"8. Unique Errors                   " + totUnique + Tab(1) + Roundoff(totUnique/num,4)*100 + Tab(1) + Roundoff(totUnique/(numCatsExp),3))


   FilePrint(report,"                                    ---------------------------")


   FilePrint(report,"8b. Trials to complete 1st cat:   "+ firstcat) 
   FilePrint(report,"9. Failure to maintain set:      "+failuretomaintain)
   FilePrint(report,"10. Learning to Learn:           "+learningtolearn)
   FilePrint(report,"11. Conceptual Level Responses:  "+conceptual)
   FilePrint(report,"    Percent CLR:                  "+Roundoff(100*(conceptual/num),1))
   
   FilePrint(report,"12. Perseverative Runs: Min    Max   Mean   Total")
   if(Length(persrun)>0)
  {
   FilePrint(report,"                         "+Min(persrun)+ "  "+ Max(persrun) + "     "  + Roundoff(Mean(persrun),3) + "   " +
   Sum(persrun))
  } else{
   FilePrint(report,"no perseverative runs")
  }
   FilePrint(report,"---------------------------------------------------")	

   FilePrint(report,"Notes:") 
   

   FilePrint(report,"Stats 1-11 are standard statistics commonly
   reported.  #1 contains both categories completed (standard stat)
   and categories experienced, whether or not the last one was
   actually completed.  Means are computed based on categories
   experienced (not categories completed), and perseverative means
   based on categories experienced AFTER the first category usually a
   maximum of 8.  Total and percent for 1-11 are computed like the
   commonly-reported stats, to the best of our knowledge. #12,
   Perseverative runs, computes the number of error perseverations in
   a row at the beginning of each new category.")

   FilePrint(report,"*PEBL, the PEBL test battery, and this test are unaffiliated with the Wells Printing Company or PAR Inc, the producers of the 'Wisconsin Card Sorting Test' (tm)")


   FilePrint(report,"New computations of perseverations according to  PAR rules:")

   out <- RunData(datatable,"data/"+gsubnum+"/bcst-par-"+gsubnum+".csv")
   totPersPAR <- Third(out)
   totPersErrPAR <- Fourth(out)

   FilePrint(report,"5. Perseverative Responses (PAR)    " + totPersPAR + Tab(1) + Roundoff(totPersPAR/num,4)*100 + Tab(1) + Roundoff(totPersPAR/(numCatsExp-1),3))
   FilePrint(report,"6. Perseverative Errors    (PAR)    " + totPersErrPAR + Tab(1) + Roundoff(totPersErrPAR/num,4)*100 + Tab(1) + Roundoff(totPersErrPAR/(numCatsExp-1),3))


   FileClose(report)


  FilePrint(pooledFile,gSubNum+","+TimeStamp()+","+(GetTime()/1000)+","+  gParams.runlength+","+numCats+","+num+","+totCorr+","+
	 err+","+totPers+","+totPersErr+","+nonp+","+totUnique+","+
	 firstcat+","+failuretomaintain+","+learningtolearn+","+
         conceptual+","+totPersPAR+","+totPersErrPar)



   ##Now, show debriefing info.



   SetText(gInstructions, gdebrief)
   Hide(gPrompt)
   Hide(gHeader)
   Show(gInstructions)
   Draw()
   Print("Finished with the Card Sort Task")
   WaitForIt()
   ShowCursor(1) 
 }


##  This is a standard initializer function that sets up typical
##  objects used in experiments.
define Initialize()
{
  ##Initialize Window, etc.
  gWin <- MakeWindow("black")   
  

          
  ##Initialize Font and colors
  gSleepEasy <- 1

   ##Get subject code if we need to:    
   if(gSubNum==0)
    {
	  gSubNum <- GetSubNum(gWin)
    }

   bg <- MakeColor("black")
   fg <- MakeColor("white")
   bg2 <- MakeColor("black")
   
   colGreen <- MakeColor("green")
   colRed   <- MakeColor("red")
 
 
   gStimFont         <- MakeFont(gPEBLBaseFontMono, 0, 24,fg,bg,0)       
   gCorrFont         <- MakeFont(gPEBLBaseFontMono, 0, 30,colGreen, bg,0)
   gIncorrFont       <- MakeFont(gPEBLBaseFontMono, 0, 30,colRed,   bg,0)


   gInstructionsFont <- MakeFont(gPEBLBaseFont,0,18, fg,bg2,1)  
   gHeaderFont       <- MakeFont(gPEBLBaseFont, 0,36,fg,bg,1)       
 
   ## Make and place the instruction box, then hide it  
   gInstructions <- MakeTextBox("", gInstructionsFont, 600,200)
   AddObject(gInstructions, gWin)
   Move(gInstructions, gVideoWidth/2-300, gVideoHeight/2+5)
   Hide(gInstructions)

   ## Make and hide a header label
   gHeader <- MakeLabel("",gHeaderFont)
   AddObject(gHeader,gWin)
   Move(gHeader, gVideoWidth/2, 100)
   Hide(gHeader)

   #Create the insturctions cue
   gPrompt <- MakeLabel(gPromptText,gStimFont)
   AddObject(gPrompt,gWin)
   Move(gPrompt,gVideoWidth/2-200,250)
   Hide(gPrompt)


   gCorrect <- MakeLabel(gCorrectText,gCorrFont)
   AddObject(gCorrect,gWin)
   Move(gCorrect,gVideoWidth/2+100,350)
   Hide(gCorrect)
  
   gIncorrect <- MakeLabel(gIncorrectText,gIncorrFont)
   AddObject(gIncorrect,gWin)
   Move(gIncorrect,gVideoWidth/2+100,350)
   Hide(gIncorrect)

 }


## This returns two 1-0 correctness stats: [last-rule, cur-rule]
define ScoreTrial(triallist, resp, rule,lastrule)
{
  ##The piles are defined by:
  ## Rule 1: COLOR:  red green blue yellow
  ## Rule 2: SHAPE:  circle star triangle cross
  ## Rule 3: NUMBER: 1 2 3 4
  ## Depending upon the rule (triallist[5]),
  ## the correct response depends upon column 1,2,3

  dimensions <- [gColors, gShapes, gNumbers]
  dimension <- Nth(triallist, rule)

  dimlist <- Nth(dimensions,rule)
   if(lastrule == -1)
   {
      lastdim <- 0 
      lastdimlist <- [-1,-1,-1,-1]
   } else {
  
     lastdim   <- Nth(triallist, lastrule)
     lastdimlist <- Nth(dimensions,lastrule)
   }
  ##So, the trial is correct if, along the chosen dimension,
  ## the response is the same as the pile.

   corr <-     (Nth(dimlist,ToInteger(resp)) == dimension)
   lastcorr <- (Nth(lastdimlist,ToInteger(resp)) == lastdim)


   if(corr)
   {
     ##It was correct
     corCur <- 1
   } else {
     corCur <- 0
   }

   if (lastcorr) 
   { 
         corLast <- 1
   } else  {
         corLast <- 0
   }
##  Print([corLast, corCur])
  return [corLast, corCur]
}


define Roundoff(x,dec)
{
  power <- 10^dec
  return   Round( x * power)/power
}


define WaitForIt()
{
  if(gParams.UseMouse)
   {
     WaitForDownClick()
   } else {
     WaitforAnyKeyPress()
   }
}


 
define RunData(data,fname)
{
  
  ##1. Do some minor checking.  
  ncol <- Length(Transpose(data))
 if(not ncol==18)
  {
    Print("Unable to compute PAR score")
 

  ##Calculate summaries of the two new statistics:
  sumPEBLPers <- SumUp(Nth(Transpose(x),15))
  sumPEBLPersErr <- SumUp(Nth(Transpose(x),16))
  sumPARPers <- -1
  sumPARPersErr <- -1
  }else {


  ##2. ScorePars expects a header row (with non-data)!!!!
  x <- ScorePAR(data)

  ##3. cobble the header back together:
  header <-    gFileHeader + ",ptp,unambig,ptpCorr,tent,tent2,corr2,PARPERS,PARPERSERR"

  ##4. Write out to a new file
  WriteCSV(fname, Merge([[header]],x))

  ##Calculate summaries of the two new statistics:
  sumPEBLPers <- SumUp(Nth(Transpose(x),15))
  sumPEBLPersErr <- SumUp(Nth(Transpose(x),16))

  sumPARPers <-  Sum(Nth(Transpose(x),25))
  sumPARPersErr <- Sum(Nth(Transpose(x),26))

##  FilePrint(gfile,fname+"," +sumPEBLPers+","+sumPEBLPersErr+","+sumPers+","+sumPersErr)

 }

  return [sumPEBLPers,sumPEBLPersErr,sumPARPers,sumPARPersErr]     
}


define ScorePAR(data)
{

  ##Extract the first header row.  
  numbers <- Sublist(data,2,Length(data))


##setup the rescoring variables
  finalData <- []
  tdata <- Transpose(numbers)
  runs <- Levels(Third(tdata))


  apparentrule <- 0
  apparentruleX <- 0
  apparentruleXX <- 0


  ptp <- 0
  ptpX <- 0
  ptpXX <- 0


  ptpCorr   <- 0
  ptpCorrX  <- 0
  ptpCorrXX <- 0

  lastrule <- 0
  rule <- 0
  norule <- 1

  ##Go through each run(category), one by one.
  loop(i, runs)
  {
#   Print("********************************************")
##this pulls out just the trials on a particular run

    run <- ToInteger(i)
    filter <- Match(Third(tdata),i)

    ##Get the trials for just this run:
    trials <- Filter(numbers,filter)
    length <- Length(trials)

    #First, establish what the PTP is for each trial

    ptps <- Repeat(0,length)
    unambigs <- Repeat(0,length)
    ptpCorrs <- Repeat(0,length)
    tentatives <- Repeat(0,length)
    count <- 0
    corrs <- Repeat(0,length) ##recompute correct trials later.

    minirun <- 0
    ptpFlag <- 0


    ##This keeps track of the number of unambiguous responses made in a row,
    ##that are unbroken by other unambiguous responses.  Note: it may be broken
    ## by ambiguous responses that are consistent with the unambiguous run


    unambigRunCounter <- 0

    ##This can increment when you have an ambiguous response consistent with
    ##the unambiguous response rule.
    consistentRunCounter <- 0
    tentativePTP <- 0


    lastrule <- rule
    rule <-ToInteger(Nth(First(trials),4))

    ##This will loop through just the trials associated with
    ##a particular run.  the rule should be the same for all of them.


	i <- 1
      while(i <= length)
       {
	 j <- Nth(trials,i)

	 ##shift the PTP on the first count of a new run,
	 ##to the previous rule.
         if(run > 1 and  count == 0)
         {
	   ptp <- lastrule
         } 


     ##Determine whether i was correct:
     corr <-  ToInteger(Nth(j,10))
     SetElement(corrs,i,corr)


     ## Determine whether the PTP rule should 
     ##
 
     ##Determine whether they are operating according to 
     ##any unambiguous rule

      corrcol <-    ToInteger(Nth(j,12))
      corrshape <-  ToInteger(Nth(j,13))
      corrnum   <-  ToInteger(Nth(j,14))



			
      if((corrcol+corrshape+corrnum)==1)
           {
	       ## The PTP is the single correct element.
	       unambigRule <- corrcol + 2*corrshape + 3*corrnum
           } else {
	       unambigRule <- 0
           }


	 if(corr == 0)
	 {

	 if(ptp==0 and run==1 and unambigrule >0)
	 {
           ptp <- unambigrule
	 }

	  if(unambigRule >0 and not (unambigRule == tentativePTP))
  	   {

	    ##We just made an unambigous error that differs from
 	    ## the previous response
            tentativePTP <- unambigRule
            unambigRunCounter <- 1
            consistentRunCounter <- 1

            }elseif(unambigRule > 0 and 
		 unambigRule == tentativePTP)
	   {
            ##we have made an unambiguous error that is the same as 
            ##tentative PTP

            unambigRunCounter <- unambigRunCounter + 1
	    consistentRunCounter <- consistentRunCounter + 1
	   }elseif(unambigRule==0) {
	     ##We made an ambiguous error.
           
	   ##was it correct according to our current tentative rule?
	     if(tentativePTP>0)
	     {
	      tptpCorr <-ToInteger(Nth([corrCol,corrShape,corrNum],tentativePTP))==1
             }else{
	      tptpCorr <- 0
	     }

	  if(tptpCorr)
	  {


	     ##If so, this is 'consistent' with the tentative PTP rule, and
	     ##so we can increment.
             consistentRunCounter <- consistentRunCounter + 1
	   } else {

	      #It is not consistent with the PTP; reset the counter
	      unambigRunCounter <- 0
              consistentRunCounter <- 0
	   }
 
         } else {
	    SignalFatalError("This should never happen.")
         }
       } else {


         ##was it correct according to our current tentative rule?
	  if(tentativePTP>0)
	  {
	   tptpCorr <-ToInteger(Nth([corrCol,corrShape,corrNum],tentativePTP))==1
          }else{

	   tptpCorr <- 0
	  }

	  ##Here is a correct trial.
	  ##if it is still consistent with the tentative PTP, keep incrementing
	  if(tptpCorr and consistentRunCounter>0)
	  {

	     consistentRunCounter <- consistentRunCounter + 1
	  } else {
	    ##Otherwise, reset the counters.

	      unambigRunCounter <- 0
              consistentRunCounter <- 0

	  }
	 }


 
        ## At this point, we have unambigRunCounter, which tells us how
	## many unambiguous errors to the tentativePTP have been made (possible
	## broken by ambiguous-but-consistent responses), and we have
	## consistentRunCounter, which tells us how far back the entire run goes.
	## if unambigRunCounter == 3, we can set the PTP that many trials back.

        ##Now, let's decide whether the PTP should change

	##When it is greater than 3, it should get picked up by other logic.
       	if(unambigRunCounter == 3)
	{

           ptp <- tentativePTP
	   loop(ii, Sequence(i-consistentRunCounter+1,i,1))
	   {
	      SetElement(ptps,ii,tentativePTP)
              ptpCorrii <- ToInteger(Nth(Nth(data,ii),11+tentativePTP))==1
	      SetElement(ptpCorrs,ii,ptpCorrii)
	   }
	}elseif(run==1 and ptp == 0)
         { 

	 ##Define PTP during first run. We set the PTP based on the first
	 ##unambiguous error in the first run.
     	if(not corr)
         {
		 ##if the ptpFlag has been set, and if this
		 ##item's unambigous rule is the same, then
		 ##we have a new PTP; otherwise, reset the flag.
		 if(ptpFlag>0 and ptpFlag == unambigRule)
		 {

	              ptp <- unambigRule
		 } else {
                      ptpFlag <- 0
 		 }

            if(unambigRule>0)
            {
             ## The NEXT PTP is the single correct element.
             ##Identify which rule tripped the PTP flag in the first
             #run.  If we see it again right away, we need to change
	     #the ptp
             ptpFlag <- unambigRule

             }

         } else {
	  ##The response was correct during the first run with no PTP; do nething
	 
	 }

     } else {
	 
	 ##Run is greater than 1, or at least we have a PTP defined
         ##Should the PTP change because of an overt rule shift?
         ##The PTP can change if you make three unambiguous 
         ##responses to the same rule in a row.



 	if(unambigRunCounter == 3) #was >=
          { 

	    
  	    ptp <-  unambigRule
          }
      }
     
      SetElement(ptps,i,ptp)
      SetElement(unambigs,i,unambigRule)


      count <- count + 1	
      i <- i + 1
    }

  
	##If trials is just one trial long, then we've hit the end 
	##of the test.  This is a special-case for one-item sets at the end.
	if(Length(trials)==1)
	{
         ptps     <- [ptp]
    	 unambigs <- [unambigRule]
	 ptpCorrs <- [ptpCorr]
	  
	}
	 


     #############################################
     ## Let's make a pass through this category and 
     ## compute ptpCorr--was this correct according to the 
     ## ptp?  Our previous computations of this were based only
     ## on tentatives, and did not go back 


     newtrials <- Transpose(Merge(Transpose(trials),[ptps,unambigs,ptpCorrs]))

     loop(x,newtrials)	
     {
       ptp <- Nth(x,19)
       ptpCorr <- Nth(x,11+ptp)==1
       SetElement(x,21, ptpCorr)

     }

     ###############################################################
     ##We have established the ptps for each of the trials within
     ##the run. Now, go through the trials and score perseverative 
     ##responses and perseverative errors  



	 ##loop through and mark possibly sandwiched items as
 	 ## tentative
	 lasttent <- 0

	 x <- 1
         ## Now, go through each trial of the current category and code its status in 
	 ## terms of 'tentative' perseverations.
         ## this will let us use the sandwich rule on the third pass (later).
         ## this is done by analyzing the PTP, which is correct at this point.
         ##
         ## Tentative scores:
         ## 0 is never a perseveration--it might be correct, or it might be 
	 ## a non-perseverative response
         ## 1 is always a perseveration.  


	 loop(kk,Sequence(1,Length(newtrials),1))
          {
          k <- Nth(newtrials,kk)

	   iCorr <- ToInteger(Nth(k,10))
           iptp <- ToInteger(Nth(k,19))
	   iUnambig <- ToInteger(Nth(k,20))
	   iptpCorr <- ToInteger(Nth(k,21))


	   ##Did the PTP just change?


	   if(kk==1)
	   {

	     iptpChange <- 0
	   } else {
              iptpChange <-  not (iptp == Nth(Nth(newtrials,kk-1),19))
	   }


	   ##This is a flag that tell us when the first rule of the test is initiated.
#	   if(norule and iptp>0)
#	   {
##	     norule <- 0
#	   }

	   if(iCorr)
	   {

	    ##if we are correct, but we are 1. ambiguous and 2. ptpCorr, code as 3;
	    ##this could be a perseveration if properly sandwiched.

	      tent <- 0
	      
             ##Note: all the rest are incorrect!!!
	   }elseif(iUnambig>0 and iptpCorr==1 and not iptpCHange)
	   {
 	   ##Simplest case first:  if it is incorrect, unambiguous, and ptpCorr, it is a perseveration.

	    tent <- 1

	   }elseif(iptpCorr ==1 and iptpChange and (not norule))
	   {
              ##We are always a perseveration if we are correct according to the PTP, we have just 
              ##switched categories (but these don't count)


	       tent <- 5

  	   } elseif(iptpCorr ==1 and norule)
	   {
              ##We are always a perseveration ON THE FIRST CATEGORY
	      ## but, like user-initiated switches, these are not counted
	      ## as perseverations, so we mark them 5


	       tent <- 5
	       norule <- 0  ##This may not be needed

  	   }elseif(iptpCorr==1 and not ( iUnambig==0) and not iptpchange) {
             ##was it an unambigous response that was a correct response to the PTP?
	     tent <- 2

          }else{

  	     tent <- 0
         }

	  if(iUnambig==0 and iptpCorr==1)
	    {
	      tent <- 3
	    }


         if(tent>0)
	   {
	     ##If not unambiguous:
	     if(iUnambig==0)
		 {
		   tent <- 3
		 }
	   }
 

	   SetElement(tentatives,x,tent)
	   lasttent <- tent
	   x <- x  + 1

           last <-k
	   
        }


	 ##Now, tentatives is written with four tokens 0 to 3.
	 ##0 is never a possible perseveration
         ##1 are always a perseveration
	 ##2 are always a perseveration, at a rule shift.
	 ##3 might be a persevaration, if sandwiched between 1s and 2s
	 ##4 (computed next) are a recoding of 3s from tentative to valid.
	 ##5 are unambiguous errors at the start of a user-initiated rule change, and so 
	 ## they don't count as perseverations.


	 ##Any tentatives must be followed by a 'sure thing'--a 1
	 ##So---go through tentatives backward and rewrite 3s to 0 when they
	 ##don't follow a 1 or 3

	 pairs <- (Transpose([tentatives,corrs]))
         ids <- Sequence(1,Length(corrs),1)

	 ##This just computes the 'sandwich rule'.  
	 ##it looks for runs of 3s sandwiched between 1s and 2s.
	 ##Any runs such as this will be changed to 4s;
	 ## non-runs will be changed to 0s.	 

	 loop(pairid,ids)
	 {
	   pair <- Nth(pairs,pairid)
	   i <- First(pair)
	   if(i==3)
	   {
	    startid <-pairid-1
	    ##Find the first element prior in the list that is not a 3.
	    endid <- pairid
	    cont <- 1
	    while(endid<(Length(corrs)+1) and cont)
	    {
	      endid <- endid+1
	      
	      ##endID might be outside the list; which means it went until a switch or the rules were over.
	      ##this can cause problems when you want to look at the endid list item....
	      if(endid<=Length(corrs))
	      {
  	      if(not First(Nth(pairs,endid)) == 3)
	      {
	        cont <- 0
	      }
	      }
	      ##OK, now the potential endpoints of the run are
	      ##startid and endid.  If either of these are
	      ## outside the bounds of the list or equal to 0, we violate the
	      ## sandwich rule and 3 becomes 0; otherwise, it becomes 4.

	      if(startid<1 or endid >Length(corrs))
	      {
	       good <- 0

	      }else {

	        good <-  (First(Nth(pairs,startid))>0 and First(Nth(pairs,endid))>0)*4
              }
 
                ##Now, we should reset the 3s in our sequence with 'good'
  

                seq <- Sequence(Max([1,startid+1]),endid-1,1)

		loop(s,seq)
		{
       		   SetElement(Nth(pairs,s),1,good)

		}

            }

          }}
	   

         #the 3s should be gone from pairs, replaced by 0s and 4s

         count <- 1
	 persevs <- []
	 perserrs <- []
	 loop(pair,pairs)
	 {

	 
	    persev <- First(pair)>0 and (not First(pair)==5)
            persevs <- Append(persevs,persev)
	    error <-  (ToInteger(Second(pair))==0)
	    perserrs <- Append(perserrs, persev and error)

	    count <- count +  1
         }
     
	   finalData <- Merge(finalData,
                    	   Transpose(Merge(Transpose(newtrials),
	                                   [tentatives,First(Transpose(pairs)),Second(Transpose(pairs)),persevs,perserrs])))

      }

   return (finalData)

}



define WriteCSV(name,table)
{
  fileout <- FileOpenOverWrite(name)
  loop(i,table)
  {
     loop(j,i)
	 {
	     FilePrint_(fileout,j+",")
     }
	 FilePrint(fileout,"")
  }
  FileClose(fileout)
}

##This find the sum of a list of numbers coded as strings.
define SumUp(list)
 {
   sum <- 0
    loop(i,list)
    {
      sum <- sum + ToNumber(i)
    }
 return sum
}
define GetStrings(lang)
{

  lang <- Uppercase(lang)
  fname <- "translations/cardsort.pbl-"+LowerCase(lang)+".csv"

  if(FileExists(fname))
  {
    gStrings <- ReadTranslation(fname,lang)
  } else
  {
    gStrings <- ReadTranslation("translations/cardsort.pbl-en.csv",lang)
  }


  #compose alternate strings for mouse and keyboard:
  if(gParams.UseMouse)
   {
     gContinue <- gStrings.continuemouse#
     gInst2 <- gStrings.inst2mouse#
     gPromptText <- gStrings.headermouse#

    }else {
    
     gContinue <- gStrings.continuekey#
     gInst2 <- gStrings.inst2key#
     gPromptText <- gStrings.headerkey#
}


   gInst1 <- gStrings.inst1 + CR(1)+gContinue#
   gInst3 <- gStrings.inst3 + CR(1) + gContinue#
   gDebrief <- gStrings.debrief#



  ## The labels/instructions live in the file labels-en.txt.  Change
  ## that file to translate to a new language.


  gCorrectText <-gStrings.correct
  gIncorrectText <- gStrings.incorrect


}
